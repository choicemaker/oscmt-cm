<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN" "http://www.w3.org/MarkUp/Wilbur/HTML32.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <meta name="GENERATOR" content="Quadralay WebWorks Publisher 2003 for Word 8.0.0.1127">
    <meta name="TEMPLATEBASE" content="Sun JavaHelp">
    <meta name="LASTUPDATED" content="12/03/03 09:28:36">
    <link rel="StyleSheet" href="document.css" type="text/css" media="screen">
    <title>6 Parsers</title>
  </head>

  <body link="#3366CC" vlink="#9999CC" text="#000000" alink="#0000CC" bgcolor="#FFFFFF">

    <table width="100%" border="0" cellpadding="0" cellspacing="0">
      <tr> 
        <td>
          <img src="images/logo.gif" width="174" height="46" alt="ChoiceMaker Technologies Logo">
        </td>
        <td align="right" valign="top">
<a href="UsersGuide-1-074.html"><img src="images/sprev.gif" border="0" alt="Previous"></a><a href="UsersGuide-1-076.html"><img src="images/snext.gif" border="0" alt="Next"></a>
        </td>
      </tr>
    </table>

    <hr align="left">

    <blockquote>
<h3 >
6	 Parsers
<a name="wp9002331"> </a></h3>
<p >
ChoiceMaker comes with a powerful set of parsing utilities based on context-free grammars (CFG) and probabilistic CFG parsers.  These CFG parsing utilities serve as the basis for highly flexible and accurate name and address parsers.  ChoiceMaker's CFG parsing utilities include a set of tools to train and test probabilistic CFG parsers.
<a name="wp9002332"> </a></p>
<div style="color: #000000;  font-size: 14pt; font-style: normal; font-weight: bold; margin-bottom: 3pt; margin-left: 36pt; margin-right: 0pt; margin-top: 12pt; text-align: justify; text-decoration: none; text-indent: -36pt; text-transform: none; vertical-align: baseline">
6.1	 Name parser<br>
<a name="wp9002333"> </a></div>
<p >
Databases store person names in a variety of ways.  Some databases have a single name field which holds the entire name.  Others have fields for first and last name.  Still others have first, middle, and last name fields, or even fields for name prefixes (Mr., Mrs., Dr., etc.), or suffixes (Jr., III, etc.).  Some databases have two name fields, but store the entire name in one or the other.
<a name="wp9002334"> </a></p>
<p >
The name parser attempts to break up a name-possibly stored in multiple fields-into its constituent pieces.  In ChoiceMaker, name parsing is performed by an instance of the NameParser2 class (so called for historical reasons), which is initialized in the configuration file (<a href="UsersGuide-1-063.html#wp9002161">Chapter V</a>).  The NameParser2 class can parse names held in one, two, three, four, or five fields, depending on the number of database fields which represent a name, but always returns an instance of ParsedName, which holds the name's constituent pieces.
<a name="wp9002335"> </a></p>
<p >
The following table lists the methods in NameParser2.
<a name="wp9002337"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Method</b></font>
<a name="wp9000750"> </a></p>
</td>
    <td><p >
<font ><b>Semantics</b></font>
<a name="wp9000751"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>NameParser2 nameParser =</em>
<a name="wp9000752"> </a></p>
<p >
<em>    NameParser2.getDefaultParser()</em>
<a name="wp9000753"> </a></p>
</td>
    <td><p >
Returns the default NameParser2, as defined in the current configuration.
<a name="wp9000754"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName name = </em>
<a name="wp9000755"> </a></p>
<p >
<em>    nameParser.parseName(String fullName)</em>
<a name="wp9000756"> </a></p>
</td>
    <td><p >
Parse a name given as a single string.
<a name="wp9000757"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName name =</em>
<a name="wp9000758"> </a></p>
<p >
<em>    nameParser.parseName(String f, String l)</em>
<a name="wp9000759"> </a></p>
</td>
    <td><p >
Parse a name given in two fields: first and last.
<a name="wp9000760"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName name =</em>
<a name="wp9000761"> </a></p>
<p >
<em>    nameParser.parseName(String f, String m, String l)</em>
<a name="wp9000762"> </a></p>
</td>
    <td><p >
Parse a name given in three fields: first, middle, and last.
<a name="wp9000763"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName name =</em>
<a name="wp9000764"> </a></p>
<p >
<em>    nameParser.parseName(String pfx, String f, String m,</em>
<a name="wp9000765"> </a></p>
<p >
<em>                                            String l, String sfx)</em>
<a name="wp9000766"> </a></p>
</td>
    <td><p >
Parse a name given in five fields: prefix (title), first name, middle name, last name, and suffix.
<a name="wp9000767"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002338"> </a></p>
<p >
The following table lists the fields and methods in NameParser2.
<a name="wp9002340"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Field/Method</b></font>
<a name="wp9000768"> </a></p>
</td>
    <td><p >
<font ><b>Semantics</b></font>
<a name="wp9000769"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.NAME_PREFIX</em>
<a name="wp9000770"> </a></p>
</td>
    <td><p >
The key for the name prefix field.
<a name="wp9000771"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.FIRST_NAME</em>
<a name="wp9000772"> </a></p>
</td>
    <td><p >
The key for the first name field.
<a name="wp9000773"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.MIDDLE_NAME</em>
<a name="wp9000774"> </a></p>
</td>
    <td><p >
The key for the middle name field.
<a name="wp9000775"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.LAST_NAME</em>
<a name="wp9000776"> </a></p>
</td>
    <td><p >
The key for the last name field.
<a name="wp9000777"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.NAME_SUFFIX</em>
<a name="wp9000778"> </a></p>
</td>
    <td><p >
The key for the name suffix field.
<a name="wp9000779"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.MAIDEN_NAME</em>
<a name="wp9000780"> </a></p>
</td>
    <td><p >
The key for the potential maiden name field.
<a name="wp9000781"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName.NICKNAME</em>
<a name="wp9000782"> </a></p>
</td>
    <td><p >
The key for the nickname field.
<a name="wp9000783"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String piece = parsedName.get(String key)</em>
<a name="wp9000784"> </a></p>
</td>
    <td><p >
Get the name piece for the specified key.
<a name="wp9000785"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String fn =</em>
<a name="wp9000786"> </a></p>
<p >
<em>    parsedName.get(ParsedName.FIRST_NAME)</em>
<a name="wp9000787"> </a></p>
</td>
    <td><p >
Get the parsed first name.
<a name="wp9000788"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String ln = </em>
<a name="wp9000789"> </a></p>
<p >
<em>    parsedName.get(ParsedName.LAST_NAME)</em>
<a name="wp9000790"> </a></p>
</td>
    <td><p >
Get the parsed last name.
<a name="wp9000791"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002341"> </a></p>
<p >
The following tables give examples, illustrating the various flavors of the parseName() method.  Note that by default, fields are capitalized, and all punctuation is removed.  Fields are null unless otherwise noted.
<a name="wp9002343"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Element</b></font>
<a name="wp9000792"> </a></p>
</td>
    <td><p >
<font ><b>Example</b></font>
<a name="wp9000793"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName name =</em>
<a name="wp9000794"> </a></p>
<p >
<em>  np.parseName(&quot;Dr. Martin Luther King, Jr.&quot;)</em>
<a name="wp9000795"> </a></p>
</td>
    <td><p >
Parse the name from a single field
<a name="wp9000796"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>NAME_PREFIX</em>
<a name="wp9000797"> </a></p>
</td>
    <td><p >
DR
<a name="wp9000798"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>FIRST_NAME</em>
<a name="wp9000799"> </a></p>
</td>
    <td><p >
MARTIN
<a name="wp9000800"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>MIDDLE_NAME</em>
<a name="wp9000801"> </a></p>
</td>
    <td><p >
LUTHER
<a name="wp9000802"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>LAST_NAME</em>
<a name="wp9000803"> </a></p>
</td>
    <td><p >
KING
<a name="wp9000804"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>NAME_SUFFIX</em>
<a name="wp9000805"> </a></p>
</td>
    <td><p >
JR
<a name="wp9000806"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002344"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Element</b></font>
<a name="wp9000807"> </a></p>
</td>
    <td><p >
<font ><b>Example</b></font>
<a name="wp9000808"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedName name =</em>
<a name="wp9000809"> </a></p>
<p >
<em>  np.parseName(&quot;Osborne Earl (Ozzie)&quot;, &quot;Smith&quot;)</em>
<a name="wp9000810"> </a></p>
</td>
    <td><p >
Parse the name from first and last name fields.
<a name="wp9000811"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>FIRST_NAME</em>
<a name="wp9000812"> </a></p>
</td>
    <td><p >
OSBORNE
<a name="wp9000813"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>MIDDLE_NAME</em>
<a name="wp9000814"> </a></p>
</td>
    <td><p >
EARL
<a name="wp9000815"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>LAST_NAME</em>
<a name="wp9000816"> </a></p>
</td>
    <td><p >
SMITH
<a name="wp9000817"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>NICKNAME</em>
<a name="wp9000818"> </a></p>
</td>
    <td><p >
OZZIE
<a name="wp9000819"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002346"> </a></p>
<p >
The name parser <font ><i>must</i></font> be customized through the configuration file. The following is a sample configuration:
<a name="wp9002348"> </a></p>
<p >
<em>&lt;module class=&quot;com.choicemaker.cm.xmlconf.XmlNameParser2Initializer&quot;&gt;</em>
<a name="wp9002349"> </a></p>
<p >
<em>&lt;tokenizer/&gt;</em>
<a name="wp9002350"> </a></p>
<p >
<em>&lt;symbolFactory class=&quot;com.choicemaker.cm.matching.en.us.name.NameSymbolFactory&quot;/&gt;</em>
<a name="wp9002351"> </a></p>
<p >
<em>&lt;grammar file=&quot;../../plugin/locale_en_us/etc/grammars/probabalisticNameGrammar.txt&quot;/&gt;</em>
<a name="wp9002352"> </a></p>
<p >
<em>&lt;standardizer class=&quot;com.choicemaker.cm.matching.en.us.name.NameStandardizer&quot;/&gt;</em>
<a name="wp9002353"> </a></p>
<p >
<em>&lt;/module&gt;</em>
<a name="wp9002354"> </a></p>
<p >
All four elements are <font ><i>mandatory</i></font>.  Although the NameParser2 can be customized by extending a class or writing a new name grammar, ChoiceMaker recommends simply copying this section into the configuration file (<a href="UsersGuide-1-063.html#wp9002161">Chapter V</a>).  NameParser2 is based on context-free grammars and can be trained on a set of parsed names.  Additionally, NameParser2 requires that several Sets and Maps be initialized in the appropriate sections of the configuration file.  For more information on configuring NameParser2, contact ChoiceMaker.
<a name="wp9002355"> </a></p>
<div style="color: #000000;  font-size: 14pt; font-style: normal; font-weight: bold; margin-bottom: 3pt; margin-left: 36pt; margin-right: 0pt; margin-top: 12pt; text-align: justify; text-decoration: none; text-indent: -36pt; text-transform: none; vertical-align: baseline">
6.2	 Address parser<br>
<a name="wp9002356"> </a></div>
<p >
The address parser is used to split an address into house number, street name, apartment number, city, state, zip, etc. The address parser can handle addresses run together, and even handle addresses with pieces transposed, for example, the apartment number before the house number and street name.  The address parser also standardizes each of the constituent pieces, normalizing &quot;Street&quot; to &quot;ST&quot;, and &quot;East&quot; to &quot;E&quot;, for example.
<a name="wp9002357"> </a></p>
<p >
Address parsing is performed by an instance of AddressParser, which returns one or more instances of ParsedAddress.  The user may desire several potential parses of an address, as he may have an application to verify that an address is valid or corresponds to an actual physical location.  Each ParsedAddress contains the constituent pieces of the address.
<a name="wp9002358"> </a></p>
<p >
The following table lists the methods of AddressParser.
<a name="wp9002359"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Method</b></font>
<a name="wp9000820"> </a></p>
</td>
    <td><p >
<font ><b>Semantics</b></font>
<a name="wp9000821"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>AddressParser addressParser =</em>
<a name="wp9000822"> </a></p>
<p >
<em>    AddressParser.getDefaultParser()</em>
<a name="wp9000823"> </a></p>
</td>
    <td><p >
Returns the default AddressParser, as defined in the current configuration.
<a name="wp9000824"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress addr = </em>
<a name="wp9000825"> </a></p>
<p >
<em>    addressParser.parseAddress(String street, String city,</em>
<a name="wp9000826"> </a></p>
<p >
<em>                                                   String state, String zip)</em>
<a name="wp9000827"> </a></p>
</td>
    <td><p >
Parse an address from its constituent fields.
<a name="wp9000828"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002360"> </a></p>
<p >
The following table lists the fields and methods of ParsedAddress.
<a name="wp9002362"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Field/Method</b></font>
<a name="wp9000829"> </a></p>
</td>
    <td><p >
<font ><b>Semantics</b></font>
<a name="wp9000830"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.HOUSE_NUMBER</em>
<a name="wp9000831"> </a></p>
</td>
    <td><p >
The key for house number.
<a name="wp9000832"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.PRE_DIRECTION</em>
<a name="wp9000833"> </a></p>
</td>
    <td><p >
The key for pre direction.
<a name="wp9000834"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.STREET_NAME</em>
<a name="wp9000835"> </a></p>
</td>
    <td><p >
The key for street name.
<a name="wp9000836"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.STREET_SUFFIX</em>
<a name="wp9000837"> </a></p>
</td>
    <td><p >
The key for street suffix.
<a name="wp9000838"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.POST_DIRECTION</em>
<a name="wp9000839"> </a></p>
</td>
    <td><p >
The key for post direction.
<a name="wp9000840"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.APARTMENT_NUMBER</em>
<a name="wp9000841"> </a></p>
</td>
    <td><p >
The key for apartment number.
<a name="wp9000842"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.APARTMENT_TYPE</em>
<a name="wp9000843"> </a></p>
</td>
    <td><p >
The key for apartment type.
<a name="wp9000844"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.CITY</em>
<a name="wp9000845"> </a></p>
</td>
    <td><p >
The key for city.
<a name="wp9000846"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.STATE</em>
<a name="wp9000847"> </a></p>
</td>
    <td><p >
The key for state.
<a name="wp9000848"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>ParsedAddress.ZIP</em>
<a name="wp9000849"> </a></p>
</td>
    <td><p >
The key for zip code.
<a name="wp9000850"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String get(String key)</em>
<a name="wp9000851"> </a></p>
</td>
    <td><p >
Returns the value of the field specified by the given key.
<a name="wp9000852"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String houseNumber =</em>
<a name="wp9000853"> </a></p>
<p >
<em>    pAddr.get(ParsedAddress.HOUSE_NUMBER)</em>
<a name="wp9000854"> </a></p>
</td>
    <td><p >
Returns the value of the house number field.
<a name="wp9000855"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String city =</em>
<a name="wp9000856"> </a></p>
<p >
<em>    pAddr.get(ParsedAddress.CITY)</em>
<a name="wp9000857"> </a></p>
</td>
    <td><p >
Returns the value of the city field.
<a name="wp9000858"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String getStreetNameAndDirection()</em>
<a name="wp9000859"> </a></p>
</td>
    <td><p >
Returns the pre-direction, street name, and post-direction fields, if they exist, joined with spaces.
<a name="wp9000860"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>String getFullStreetName()</em>
<a name="wp9000861"> </a></p>
</td>
    <td><p >
Returns the pre-direction, street name, street suffix, and post-directions fields (if they exist), joined with spaces.
<a name="wp9000862"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002363"> </a></p>
<p >
The following table lists a few examples:
<a name="wp9002365"> </a></p>
<p >


<table border="1" cellpadding="5" cellspacing="0">
  <caption></caption>
  <tr>
    <td><p >
<font ><b>Element</b></font>
<a name="wp9000863"> </a></p>
</td>
    <td><p >
<font ><b>Example 1</b></font>
<a name="wp9000864"> </a></p>
</td>
    <td><p >
<font ><b>Example 2</b></font>
<a name="wp9000865"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
input s
<a name="wp9000866"> </a></p>
</td>
    <td><p >
10 SAINT JOHNS STREET #5H
<a name="wp9000867"> </a></p>
</td>
    <td><p >
23E78ST, 11TH FLOOR
<a name="wp9000868"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>HOUSE_NUMBER</em>
<a name="wp9000869"> </a></p>
</td>
    <td><p >
10
<a name="wp9000870"> </a></p>
</td>
    <td><p >
23
<a name="wp9000871"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>STREET_NAME</em>
<a name="wp9000872"> </a></p>
</td>
    <td><p >
ST JOHNS
<a name="wp9000873"> </a></p>
</td>
    <td><p >
E 78TH
<a name="wp9000874"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>APARTMENT_NUMBER</em>
<a name="wp9000875"> </a></p>
</td>
    <td><p >
5H
<a name="wp9000876"> </a></p>
</td>
    <td><p >
11
<a name="wp9000877"> </a></p>
</td>
  </tr>
  <tr>
    <td><p >
<em>APARTMENT_TYPE</em>
<a name="wp9000878"> </a></p>
</td>
    <td></td>
    <td><p >
FLR
<a name="wp9000880"> </a></p>
</td>
  </tr>
</table>




<a name="wp9002366"> </a></p>
<p >
The address parser <font ><i>must</i></font> be customized through the configuration file. The following gives a sample configuration:
<a name="wp9002368"> </a></p>
<p >
<em>&lt;module class=&quot;com.choicemaker.cm.xmlconf.XmlAddressParserInitializer&quot;&gt;</em>
<a name="wp9002369"> </a></p>
<p >
<em>&lt;tokenizer&gt;</em>
<a name="wp9002370"> </a></p>
<p >
<em>&lt;/tokenizer&gt;</em>
<a name="wp9002371"> </a></p>
<p >
<em>	&lt;tokenizer&gt;</em>
<a name="wp9002372"> </a></p>
<p >
<em>		&lt;preDirections&gt;directionsToSplit&lt;/preDirections&gt;</em>
<a name="wp9002373"> </a></p>
<p >
<em>		&lt;streetSuffixes&gt;streetSuffixes&lt;/streetSuffixes&gt;</em>
<a name="wp9002374"> </a></p>
<p >
<em>		&lt;postDirections&gt;directionsToSplit&lt;/postDirections&gt;</em>
<a name="wp9002375"> </a></p>
<p >
<em>		&lt;aptTypes&gt;aptTypes&lt;/aptTypes&gt;</em>
<a name="wp9002376"> </a></p>
<p >
<em>	&lt;/tokenizer&gt;</em>
<a name="wp9002377"> </a></p>
<p >
<em>	&lt;symbolFactory class=&quot;com.choicemaker.cm.matching.en.us.address.AddressSymbolFactory&quot;/&gt;</em>
<a name="wp9002378"> </a></p>
<p >
<em>	&lt;grammar file=&quot;../../plugin/locale_en_us/etc/grammars/probabalisticAddressGrammar.txt&quot;/&gt;</em>
<a name="wp9002379"> </a></p>
<p >
<em>	&lt;standardizer class=&quot;com.choicemaker.cm.matching.en.us.address.AddressStandardizer&quot;/&gt;</em>
<a name="wp9002380"> </a></p>
<p >
<em>&lt;/module&gt;</em>
<a name="wp9002381"> </a></p>
<p >
As with the name parser, the address parser can be customized by overriding one or more classes, creating or training a new grammar, or changing the Sets and Maps to use in certain parts of the address parser.  For more information, contact ChoiceMaker directly.
<a name="wp9002382"> </a></p>
    </blockquote>
    <p></p>
    <hr>

    <table width="100%" border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td valign="top">
<a href="UsersGuide-1-074.html"><img src="images/sprev.gif" border="0" alt="Previous"></a><a href="UsersGuide-1-076.html"><img src="images/snext.gif" border="0" alt="Next"></a>
        </td>
        <td align="right">
         <font size="3"><b>
           ChoiceMaker Technologies<br>
         </b></font>
         <font size="3">
           <a href="http://www.choicemaker.com">http://www.choicemaker.com</a><br>
           Voice: (212) 905-6030<br>
           Fax: (212) 331-1106<br>
           <a href="mailto:info@choicemaker.com">info@choicemaker.com</a><br>
         </font>
        </td>
      </tr>
    </table>
  </body>
</html>
