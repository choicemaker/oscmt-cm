/*
 * Copyright (c) 2001, 2022 ChoiceMaker LLC and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License
 * v1.0 which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     ChoiceMaker Technologies, Inc. - initial API and implementation
 */
package com.choicemaker.cmit.online;

import java.io.File;
import java.security.Permission;
import java.util.Date;

import com.choicemaker.cm.compiler.impl.CompilerFactory;
import com.choicemaker.cm.core.Match;
import com.choicemaker.cm.core.ModelConfigurationException;
import com.choicemaker.cm.core.Record;
import com.choicemaker.cm.core.XmlConfException;
import com.choicemaker.cm.core.compiler.ICompiler;
import com.choicemaker.cm.core.util.CommandLineArguments;
import com.choicemaker.cm.core.xmlconf.ProbabilityModelsXmlConf;
import com.choicemaker.cm.core.xmlconf.XmlConfigurator;
import com.choicemaker.e2.CMPlatformRunnable;

/**
 * A command-line application that tests online matching services. The test
 * requires a running CM Server instance and the output report file from an
 * online matching session. This application reads the report file and for each
 * query record contained in the report, it submits the query record to the CM
 * Server instance.
 * <p>
 * This use of report files allows one to generate scripts for regression
 * testing automatically. Most production installations of CM Server should have
 * reporting enabled for auditing purposes. If so, the reports generated by the
 * production server can be used as scripts for this program. In turn, if
 * reporting is enabled for the CM Server instance in the test or development
 * environment, the reports generated by the server as this program is run can
 * be compared to the reports from the production server. In general, there will
 * be several types of differences between the test and production reports:
 * <p>
 * <ul>
 * <li/><em>Inconsequential</em><br/>
 * Differences such as timestamps and minor differences in operation durations
 * <li/><em>Data-dependent</em><br/>
 * The data in a production server is likely to be different at the time a
 * report was generated from the data in a test server at the time this test is
 * run
 * <li/><em>Model- or software-dependent</em><br/>
 * This is the most interesting category for testing purposes. If the model on a
 * test server has changed compared to the production model, or if there's been
 * a software modification that affects matching results, then these differences
 * are likely to show up as differences in report results if a sufficiently
 * diverse set of queries are contained in report file.
 * </ul>
 * <p>
 * To minimize inconsequential and data-dependent differences, the report files
 * can be generated from a production server, but then run against a "golden"
 * deployment of CM Server and some archived set of "golden" data. The report
 * generated from running this test against golden standards and then be used
 * for the comparison base for future regression tests as models and software
 * are modified during development. The golden report file can also be archived
 * under a source code control system (perhaps in encrypted form if the data in
 * the report is confidential or sensitive).
 * </p>
 * 
 * @author rphall
 * @version $Revision$ $Date$
 */
public abstract class OnlineTest implements CMPlatformRunnable {

	public static enum MODEL_SOURCE {
		RESOURCE(true), FILE(false);
		public final boolean initFlag;

		MODEL_SOURCE(boolean flag) {
			this.initFlag = flag;
		}
	}

	public static final MODEL_SOURCE DEFAULT_MODEL_SOURCE = MODEL_SOURCE.FILE;

	private final IRecordMatchingClient onlineClient;

	public OnlineTest(IRecordMatchingClient onlineClient) {
		this.onlineClient = onlineClient;
		if (onlineClient == null) {
			throw new IllegalArgumentException("null online client");
		}
	}

	protected abstract Object getMatchingParams(String strSpecification,
			String[] extraParams) throws Exception;

	/**
	 * Runs this class as an Eclipse command-line application.
	 * 
	 * @param args
	 *            command-line arguments for the application. All are required:
	 *            <ul>
	 *            <li/>-conf &lt;path-to-project.xml&gt;<br>
	 *            e.g.
	 *            <code>-conf C:/eclipse/workspace/projects/citeseer/project.xml</code>
	 *            <li/>-matchParams &lt;a property file specifying match
	 *            parameters&gt;
	 *            <li/>-report <&lt;a report file generated during online
	 *            matching&gt;
	 *            </ul>
	 *            In addition, the usual Java and Eclipse command-line arguments
	 *            are required, namely the extension id for this application. A
	 *            minimal command line for starting this application from the
	 *            Eclipse directory would look like the following:
	 * 
	 *            <pre>
	 * java -cp startup.jar org.eclipse.core.launcher.Main
	 *         -application com.choicemaker.cmit.online.urm.UrmOnlineTest
	 *         -conf C:/eclipse/workspace/projects/citeseer/project.xml
	 *         -matchParams C:/temp/citeseer.properties
	 *         -report C:/temp/Report.2007-08-28.xml
	 * </pre>
	 * 
	 *            This command should be typed on a single line; it is broken
	 *            across multiple lines here for readability.
	 */
	public Object run(Object args) throws Exception {

		CommandLineArguments cla = new CommandLineArguments(true);
		cla.addArgument("-conf");
		cla.addArgument("-report");
		cla.addArgument("-matchParams");

		String[] arCmdLineArgs = (String[]) args;
		cla.enter(arCmdLineArgs);

		String fnConf = cla.getArgument("-conf");
		if (fnConf == null) {
			throw new IllegalArgumentException("Must provide a -conf argument");
		}
		XmlConfigurator.getInstance().init(fnConf, null, true, false);
		refreshProductionProbabilityModels();

		String strMatchParams = cla.getArgument("-matchParams");
		if (strMatchParams == null) {
			throw new IllegalArgumentException(
					"Must provide a -matchParams argument");
		}
		Object matchingParams =
			getMatchingParams(strMatchParams, arCmdLineArgs);

		String fnReport = cla.getArgument("-report");
		if (fnReport == null) {
			throw new IllegalArgumentException(
					"Must provide a -report argument");
		}

		final ClassLoader origCL =
			Thread.currentThread().getContextClassLoader();
		final ClassLoader taskCL = this.getClass().getClassLoader();

		QueryStatistics statistics = new QueryStatistics();
		ReportParser reportParser = null;
		Throwable nonmatchingError = null;
		try {

			Thread.currentThread().setContextClassLoader(taskCL);
			if (System.getSecurityManager() == null) {
				System.setSecurityManager(new SecurityManager() {
					public void checkPermission(Permission perm) {
					}
				});
			}

			File reportFile = new File(fnReport).getAbsoluteFile();
			reportParser = new ReportParser(reportFile);
			reportParser.open();
			while (reportParser.hasNext()) {

				Query input = (Query) reportParser.next();
				QueryParams queryParams = input.getQueryParams();
				Record queryRecord = input.getQueryRecord();

				Match[] matches = null;
				Throwable error = null;
				Date timestamp = new Date();
				try {
					matches =
						onlineClient.getMatches(matchingParams, queryParams,
								queryRecord);
				} catch (Throwable t) {
					error = t;
				}
				long finishTime = new Date().getTime();
				long duration = finishTime - timestamp.getTime();

				QueryMetrics queryMetrics = new QueryMetrics();
				queryMetrics.setTimestamp(timestamp);
				queryMetrics.setDuration(duration);

				QueryError[] errors;
				if (error == null) {
					errors = new QueryError[0];
				} else {
					QueryError qe = new QueryError(error);
					errors = new QueryError[] { qe };
				}

				Query result =
					new Query(queryParams, queryRecord, matches, errors,
							queryMetrics);

				QueryComparison comparison = new QueryComparison(input, result);

				statistics.add(comparison);
			}

		} catch (Throwable t) {
			nonmatchingError = t;
			StatusUtil.printDebug("Unexpected", t);

		} finally {
			if (reportParser != null) {
				reportParser.close();
				reportParser = null;
			}
			Thread.currentThread().setContextClassLoader(origCL);
		}

		StatusUtil.reportStatistics(statistics);

		Object retVal = nonmatchingError == null ? null : new Integer(-1);
		return retVal;
	}

	private static void refreshProductionProbabilityModels()
			throws XmlConfException, ModelConfigurationException {
		refreshProductionProbabilityModels(DEFAULT_MODEL_SOURCE);
	}

	private static void refreshProductionProbabilityModels(
			MODEL_SOURCE modelSource) throws XmlConfException,
			ModelConfigurationException {

		if (modelSource == null) {
			modelSource = DEFAULT_MODEL_SOURCE;
		}

		// TODO FIXME replace default compiler with configurable compiler
		CompilerFactory factory = CompilerFactory.getInstance();
		ICompiler compiler = factory.getDefaultCompiler();

		ProbabilityModelsXmlConf.loadProductionProbabilityModels(compiler,
				modelSource.initFlag);
	}

}
