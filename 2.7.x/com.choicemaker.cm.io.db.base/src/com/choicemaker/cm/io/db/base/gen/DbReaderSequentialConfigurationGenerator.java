/*
 * Copyright (c) 2001, 2009 ChoiceMaker Technologies, Inc. and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License
 * v1.0 which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     ChoiceMaker Technologies, Inc. - initial API and implementation
 */
package com.choicemaker.cm.io.db.base.gen;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.jdom.Element;

import com.choicemaker.cm.core.Constants;
import com.choicemaker.cm.core.DerivedSource;
import com.choicemaker.cm.core.gen.CoreTags;
import com.choicemaker.cm.core.gen.GenException;
import com.choicemaker.cm.core.gen.GeneratorHelper;
import com.choicemaker.cm.core.gen.IGenerator;
import com.choicemaker.cm.core.gen.GeneratorHelper.Id;
import com.choicemaker.cm.io.db.base.DbField;

/**
 * Description
 *
 * @author    Martin Buechi
 * @version   $Revision: 1.2 $ $Date: 2010/03/28 09:06:55 $
 */
public class DbReaderSequentialConfigurationGenerator {
	private static final List EMPTY_LIST = new ArrayList(0);

	private static DerivedSource src = DerivedSource.valueOf("db");

	private IGenerator g;
	String confName;
	private DerivedSource conf;
	private Element def;
	private boolean virtualRootRecord;
	String className;

	DbReaderSequentialConfigurationGenerator(IGenerator g, String confName, Element def) throws GenException {
		this.g = g;
		this.confName = confName;
		this.conf = DerivedSource.valueOf(confName);
		this.def = def;
		generate();
	}

	private void generate() throws GenException {
		String classNameBase = g.getSchemaName() + "__" + confName + "__DbReader";
		className = classNameBase + "Sequential";
		String packageName = g.getPackage() + ".db";
		try {
			String directoryName = g.getSourceCodePackageRoot() + File.separator + "db";
			String fileName = directoryName + File.separator + className + ".java";
			g.addGeneratedFile(fileName);
			FileOutputStream fs = new FileOutputStream(new File(fileName).getAbsoluteFile());
			Writer w = new OutputStreamWriter(new BufferedOutputStream(fs));
			w.write("// Generated by ChoiceMaker. Do not edit." + Constants.LINE_SEPARATOR);
			w.write("package " + packageName + ";" + Constants.LINE_SEPARATOR);
			w.write("import org.apache.log4j.*;" + Constants.LINE_SEPARATOR);
			w.write("import java.util.*;" + Constants.LINE_SEPARATOR);
			w.write("import java.sql.*;" + Constants.LINE_SEPARATOR);
			w.write("import com.choicemaker.cm.core.*;" + Constants.LINE_SEPARATOR);
			w.write("import com.choicemaker.cm.io.db.base.*;" + Constants.LINE_SEPARATOR);
			w.write("import " + g.getPackage() + ".*;" + Constants.LINE_SEPARATOR);
			w.write(g.getImports());
			w.write("public final class " + className + " implements DbReaderSequential {" + Constants.LINE_SEPARATOR);
			w.write("private static Logger logger = Logger.getLogger(" + packageName + "." + className + ".class);" + Constants.LINE_SEPARATOR);
			w.write("private ResultSet rs;" + Constants.LINE_SEPARATOR);
			w.write("private List res = new ArrayList();" + Constants.LINE_SEPARATOR);
			w.write("private int resSize;" + Constants.LINE_SEPARATOR);
			w.write("private Iterator iRes;" + Constants.LINE_SEPARATOR);
			w.write("private ArrayList l = new ArrayList();" + Constants.LINE_SEPARATOR);
			w.write("private static DerivedSource src = DerivedSource.valueOf(\"db\");" + Constants.LINE_SEPARATOR);
			w.write("public String getName() {" + Constants.LINE_SEPARATOR);
			w.write("return \"" + g.getSchemaName() + ":r:" + confName + "\";" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			Element rootRecord = g.getRootRecord();
			w.write("public void open(ResultSet rs, Statement stmt) throws java.sql.SQLException {" + Constants.LINE_SEPARATOR);
			w.write("this.rs = rs;" + Constants.LINE_SEPARATOR);
			callGetters(w, rootRecord, 0);
			w.write("rs.close();" + Constants.LINE_SEPARATOR);
			w.write("iRes = res.iterator();" + Constants.LINE_SEPARATOR);
			w.write("l = null;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public Record getNext() {" + Constants.LINE_SEPARATOR);
			w.write("Record r = (Record)iRes.next();" + Constants.LINE_SEPARATOR);
			w.write("r.computeValidityAndDerived(src);" + Constants.LINE_SEPARATOR);
			w.write("return r;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public boolean hasNext() {" + Constants.LINE_SEPARATOR);
			w.write("return iRes.hasNext();" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public int getNoCursors() {" + Constants.LINE_SEPARATOR);
			w.write("return " + classNameBase + "Parallel.NO_CURSORS;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			writeGetters(g, w, rootRecord, new LinkedList(), 0, new LinkedList());
			w.write("public String getMasterId() {" + Constants.LINE_SEPARATOR);
			w.write("return " + classNameBase + "Parallel.masterId;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public String getMasterIdType() {" + Constants.LINE_SEPARATOR);
			w.write("return " + classNameBase + "Parallel.masterIdType;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public DbView[] getViews() {" + Constants.LINE_SEPARATOR);
			w.write("return " + classNameBase + "Parallel.views;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.flush();
			fs.close();
		} catch (IOException ex) {
			throw new GenException("Problem writing file.", ex);
		}
	}

	private void callGetters(Writer w, Element r, int idx) throws IOException {
		if (idx == 0) {
			Element hd = GeneratorHelper.getNodeTypeExt(r, "db");
			if (hd != null) {
				virtualRootRecord = "true".equals(hd.getAttributeValue("virtual"));
			}
		}
		if ((idx > 0 && !virtualRootRecord) || idx > 1) {
			w.write("stmt.getMoreResults();" + Constants.LINE_SEPARATOR);
			w.write("this.rs = stmt.getResultSet();" + Constants.LINE_SEPARATOR);
		}
		if (idx > 0 || !virtualRootRecord) {
			String className = r.getAttributeValue("className");
			w.write("getRecord" + className + "();" + Constants.LINE_SEPARATOR);
			if ((!virtualRootRecord && idx == 0) || (virtualRootRecord && idx == 1)) {
				w.write("resSize = res.size();" + Constants.LINE_SEPARATOR);
				w.write("if(resSize != 0) {" + Constants.LINE_SEPARATOR);
			}
		}
		List records = r.getChildren(CoreTags.NODE_TYPE);
		Iterator iR = records.iterator();
		while (iR.hasNext()) {
			callGetters(w, (Element) iR.next(), idx + 1);
		}
		if ((!virtualRootRecord && idx == 0) || (virtualRootRecord && idx == 1)) {
			w.write("}" + Constants.LINE_SEPARATOR);
		}
	}

	private void writeGetters(IGenerator g, Writer w, Element r, LinkedList ids, int level, LinkedList outers)
		throws IOException {
		String recordName = r.getAttributeValue("name");
		String className = r.getAttributeValue("className");

		//begin debug
		System.out.println ("DbReaderSequentialConfigurationGenerator");
		System.out.println ("confName " + confName + " recordName " + recordName + " className " + className);
		/*
		Element test0 = r.getChild("nodeTypeExt");
		List test = test0.getChildren("dbNodeType");
		for (int i=0; i<test.size(); i++) {
			Element et = (Element) test.get(i);
			System.out.println ("element " + et.getName() + " " + et.getAttributeValue("conf") + " " + et.getAttributeValue("from"));
		}
		//end debug
*/
		Element hd = GeneratorHelper.getNodeTypeExt(r, "db", confName);
		String rootClassName = null;
		if (hd == null) {
			g.error("Missing dbHd in record " + recordName + " of configuration " + confName);
			return;
		}
		List records = r.getChildren(CoreTags.NODE_TYPE);
		if (level == 0 && virtualRootRecord) {
			if (records.size() != 1) {
				g.error("Virtual root record must have exactly 1 nested record.");
			}
		} else {
			String defaultTable = hd.getAttributeValue("table");
			if (defaultTable == null)
				defaultTable = hd.getAttributeValue("from");
			w.write("private void getRecord" + className + "() throws java.sql.SQLException {" + Constants.LINE_SEPARATOR);
			w.write("String __tmpStr;" + Constants.LINE_SEPARATOR);
			for (int i = 0; i < level; ++i) {
				w.write("int i" + i + " = -1;" + Constants.LINE_SEPARATOR);
			}
			if (level != 0) {
				w.write("boolean first = true;" + Constants.LINE_SEPARATOR);
				rootClassName = ((Element) outers.get(0)).getAttributeValue("className");
				w.write(rootClassName + " rcrd = null;" + Constants.LINE_SEPARATOR);
			}
			w.write("while(rs.next()) {" + Constants.LINE_SEPARATOR);
			w.write(className + " r = new " + className + "();" + Constants.LINE_SEPARATOR);
			List fields = new ArrayList(r.getChildren("field"));
			
			System.out.println ("fields size: " + fields.size());
			GeneratorHelper.filterFields2(fields, src, "dbField", confName);
			System.out.println ("fields size: " + fields.size());
			
			DbField[] dbFields = new DbField[fields.size() + ids.size()];
			List keyTables = hd.getChildren("key");
			int fieldNo = 0;
			Iterator iL = ids.iterator();
			while (iL.hasNext()) {
				++fieldNo;
				Id id = (Id) iL.next();
				w.write(
					id.type
						+ " r__"
						+ id.name
						+ " = "
						+ DbReaderConfigurationsGenerator.getField(-1, fieldNo, id.type, g.isIntern())
						+ ";" + Constants.LINE_SEPARATOR);
			}
			Iterator iF = fields.iterator();
			while (iF.hasNext()) {
				++fieldNo;
				Element field = (Element) iF.next();
				String fieldName = field.getAttributeValue("name");
				w.write("r." + fieldName + " = ");
				w.write(
					DbReaderConfigurationsGenerator.getField(
						-1,
						fieldNo,
						field.getAttributeValue("type"),
						g.isIntern())
						+ ";" + Constants.LINE_SEPARATOR);
			}
			Iterator iRecords = records.iterator();
			while (iRecords.hasNext()) {
				Element nr = (Element) iRecords.next();
				w.write(
					"r."
						+ nr.getAttributeValue("name")
						+ " = "
						+ nr.getAttributeValue("className")
						+ ".__zeroArray;" + Constants.LINE_SEPARATOR);
			}
			if (level == 0) {
				w.write("res.add(r);" + Constants.LINE_SEPARATOR);
				w.write("}" + Constants.LINE_SEPARATOR);
			} else {
				int outerssize = outers.size();
				Id id = (Id) ids.get(0);
				w.write(
					"if(i0 < 0 || "
						+ GeneratorHelper.compareField("rcrd." + id.name, "r__" + id.name, id.type, false)
						+ ") {" + Constants.LINE_SEPARATOR);
				String dump = getDump(outers, recordName, className);
				w.write(dump);
				if (level == 1 && virtualRootRecord) {
					w.write("rcrd = new " + rootClassName + "();" + Constants.LINE_SEPARATOR);
					w.write("rcrd." + id.name + " = r__" + id.name + ";" + Constants.LINE_SEPARATOR);
					w.write("res.add(rcrd);" + Constants.LINE_SEPARATOR);
					w.write("++i0;" + Constants.LINE_SEPARATOR);
				} else {
					w.write(
						"while(++i0 < resSize && (rcrd = ("
							+ rootClassName
							+ ")res.get(i0)) != null && "
							+ GeneratorHelper.compareField("rcrd." + id.name, "r__" + id.name, id.type, false)
							+ ") {}" + Constants.LINE_SEPARATOR);
					w.write("if(i0 == resSize) {" + Constants.LINE_SEPARATOR);
					w.write("logger.warn(\"No matching outer record found.\");" + Constants.LINE_SEPARATOR);
					w.write("return;" + Constants.LINE_SEPARATOR);
					w.write("}" + Constants.LINE_SEPARATOR);
				}
				if (outerssize > 1) {
					w.write("i1 = -1;" + Constants.LINE_SEPARATOR);
				}
				w.write("}" + Constants.LINE_SEPARATOR);
				String acc = "rcrd";
				for (int i = 1; i < outerssize; ++i) {
					String ii = "i" + i;
					String baseacc = acc + "." + ((Element) outers.get(i)).getAttributeValue("name");
					acc = baseacc + "[" + ii + "]";
					id = (Id) ids.get(i);
					String compare = GeneratorHelper.compareField(acc + "." + id.name, "r__" + id.name, id.type, false);
					w.write("if(" + ii + " < 0 || " + compare + ") {" + Constants.LINE_SEPARATOR);
					w.write(dump);
					w.write("while(++" + ii + " < " + baseacc + ".length && " + compare + ") {}" + Constants.LINE_SEPARATOR);
					w.write("if(" + ii + " == " + baseacc + ".length) {" + Constants.LINE_SEPARATOR);
					w.write("logger.warn(\"No matching outer record found.\");" + Constants.LINE_SEPARATOR);
					w.write("return;" + Constants.LINE_SEPARATOR);
					w.write("}" + Constants.LINE_SEPARATOR);
					if (i + 1 < outerssize) {
						w.write("i" + (i + 1) + " = -1;" + Constants.LINE_SEPARATOR);
					}
					w.write("}" + Constants.LINE_SEPARATOR);
				}
				w.write("r.outer = " + acc + ";" + Constants.LINE_SEPARATOR);
				w.write("l.add(r);" + Constants.LINE_SEPARATOR);
				w.write("first = false;" + Constants.LINE_SEPARATOR);
				w.write("}" + Constants.LINE_SEPARATOR);
				w.write(dump);
			}
			w.write("}" + Constants.LINE_SEPARATOR);
		}
		if (!records.isEmpty()) {
			Id key = GeneratorHelper.getId(g, r, "db");
			ids.add(key);
			outers.add(r);
			Iterator iR = records.iterator();
			while (iR.hasNext()) {
				writeGetters(g, w, (Element) iR.next(), ids, level + 1, outers);
			}
			ids.removeLast();
			outers.removeLast();
		}
	}

	private String getDump(List outers, String recordName, String className) {
		StringBuffer b = new StringBuffer();
		b.append("if(!first) {" + Constants.LINE_SEPARATOR);
		b.append("rcrd");
		for (int i = 1; i < outers.size(); ++i) {
			b.append("." + ((Element) outers.get(i)).getAttributeValue("name") + "[i" + i + "]");
		}
		b.append("." + recordName + " = (" + className + "[])l.toArray(new " + className + "[l.size()]);" + Constants.LINE_SEPARATOR);
		b.append("l.clear();" + Constants.LINE_SEPARATOR);
		b.append("first = true;" + Constants.LINE_SEPARATOR);
		b.append("}" + Constants.LINE_SEPARATOR);
		return b.toString();
	}

	private String ifNotNull(String def, String val) {
		return val != null ? val : def;
	}

}
