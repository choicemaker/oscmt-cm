/*
 * Copyright (c) 2001, 2009 ChoiceMaker Technologies, Inc. and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License
 * v1.0 which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     ChoiceMaker Technologies, Inc. - initial API and implementation
 */
package com.choicemaker.cm.urm.cmcherel;


import java.rmi.RemoteException;
import java.util.Iterator;

import com.choicemaker.cm.urm.base.IRecordCollection;
import com.choicemaker.cm.urm.base.RefRecordCollection;
import com.choicemaker.cm.urm.exceptions.ArgumentException;
import com.choicemaker.cm.urm.exceptions.CmRuntimeException;
import com.choicemaker.cm.urm.exceptions.ConfigException;
import com.choicemaker.cm.urm.exceptions.ModelException;
import com.choicemaker.cm.urm.exceptions.RecordCollectionException;

/**
 * Allows a client application to match specified records collections in a
 * batch(asynchronous) mode.
 * <p>
 * The below example demonstrates how the <code>startMatching</code> would be
 * invoked within the client application.
 * 
 * <pre>
 * InitialContext initialContext = new InitialContext();
 * Object queryHomeRef =
 * 	initialContext.lookup(&quot;java:comp/env/ejb/BatchRecordMatcher&quot;);
 * BatchRecordMatcherHome qsh =
 * 	(BatchRecordMatcherHome) PortableRemoteObject.narrow(queryHomeRef,
 * 			BatchRecordMatcherHome.class);
 * BatchRecordMatcher qs = qsh.create();
 * 
 * String qu = request.getParameter(&quot;QueryURL&quot;);
 * TextRefRecordCollection qRc =
 * 	new TextRefRecordCollection(qu, new XmlTextFormat());
 * String mu = request.getParameter(&quot;MasterURL&quot;);
 * TextRefRecordCollection mRc =
 * 	new TextRefRecordCollection(mu, new XmlTextFormat());
 * String trackingId = request.getParameter(&quot;Tracking Id&quot;);
 * 
 * String temp = request.getParameter(&quot;dth&quot;);
 * float diffTh = Float.parseFloat(temp);
 * temp = request.getParameter(&quot;mth&quot;);
 * float matchTh = Float.parseFloat(temp);
 * 
 * long l =
 * 	qs.startMatching(qRc, mRc, &quot;BatchMatch&quot;, diffTh, matchTh, 1000, trackingId);
 * System.out.println(&quot;Matching Service created job with ID = &quot; + l);
 * </pre>
 * 
 * Method <code>startMatching</code> stars matching process and returns
 * immediately with the identifier of the started job. Using this identifier the
 * client application can check the job status as it shown below.
 * 
 * <pre>
 * JobStatus st = qs.getJobStatus(l);
 * </pre>
 * 
 * Once the job is completed the result file can be copied to the specified URL
 * or can be traversed using the iterator. An example of the result copying is
 * shown below.
 * 
 * <pre>
 * String res = request.getParameter(&quot;ResultURL&quot;);
 * TextRefRecordCollection resRc =
 * 	new TextRefRecordCollection(res, new DelimitedTextFormat(','));
 * String temp1 = request.getParameter(&quot;idres&quot;);
 * long id = Long.parseLong(temp1);
 * qs.copyResult(id, resRc);
 * </pre>
 * <p>
 * The result consists of the evaluated record pairs that are stored in the
 * following format
 * 
 * <pre>
 * &lt;f1, id1, f2, id2, p, d, l&gt;
 * </pre>
 * 
 * where
 * <ul>
 * <li><code>f1</code> is the format of the first (query) record ID</li>
 * <li><code>id1</code> is the query record ID</li>
 * <li><code>f2</code> is the format of the second (query or master) record ID</li>
 * <li><code>id2</code> is the master record ID</li>
 * <li><code>p</code> is the probability of match</li>
 * <li><code>d</code> is the decision (M - match, H - hold, D - differ)</li>
 * <li><code>l</code> is the location of the second record (S - query record
 * collection, D - master record collection)
 * </ul>
 *
 * @author emoussikaev
 */
public interface BatchRecordMatcher extends BatchBase {
	
	 long 	startMatching(
						IRecordCollection qRc, 
						RefRecordCollection mRc,
						String confName, 
						String trackingId) 
					throws
						ModelException, 	
						RecordCollectionException,
						ConfigException,
						ArgumentException,
						CmRuntimeException, 
						RemoteException;
 
	 long 	startMatching(
						IRecordCollection qRc, 
						RefRecordCollection mRc,
						String confName,
						CmConfiguration overrideProps,
						String trackingId) 
					throws
						ModelException, 	
						RecordCollectionException,
						ConfigException,
						ArgumentException,
						CmRuntimeException, 
						RemoteException;

	 long 	startMatching(
						IRecordCollection qRc, 
						RefRecordCollection mRc,
						RefRecordCollection resRc,
						String confName,
						CmConfiguration overrideProps,
						String trackingId) 
					throws
						ModelException, 	
						RecordCollectionException,
						ConfigException,
						ArgumentException,
						CmRuntimeException, 
						RemoteException;

	 Iterator	getResultIter(RefRecordCollection rc)
					throws
						RecordCollectionException,
						ArgumentException,
						CmRuntimeException, 
						RemoteException;

	 Iterator	getResultIter(long jobId)
					throws
						RecordCollectionException,
						ArgumentException,
						CmRuntimeException, 
						RemoteException;

	 long[] 		getJobList()
							throws	ArgumentException,
									ConfigException,
									CmRuntimeException, 
									RemoteException;
														
}



























//import com.choicemaker.cm.urm.base.ISingleRecord;
/*
 * Finds the record pairs with the first element defined by the profile and the second element from the master record collection 
 * with the matching probability greater then or equal to <code>differThreshold</code> . 
 * This is an asynchronous method that returns immidiately after the matching process was started. 
 * The result is serialized to the provided record collection in the "mathing result" format.
 * 
 * @param   qRecord  	The holder object that stores query record.
 * @param   mRs  		The master record source. 
 * @param	modelName	The name of the probability model.
 * @param	differThreshold  Matching probability below this threshold constitutes the differ.
 * @param	matchThreshold   Matching probability above this threshold constitutes the match.
 * @param	maxNumMatches	 Limits number od records included into the resulting array.
 * @param	clientSticker	 Included in log messages as the way to identify related information	
 * @return  The corresponding <code>MatchResult</code>.
 * @throws  RemoteException
 */
/* 	
public long 		startMatching(
								ISingleRecord qProfile, 
								IDbRecordCollection mRs,
								String modelName, 
								float differThreshold, 
								float matchThreshold,
								String externalId) 
							throws 	InvalidModelException, 	
									RecordException, 
									DatabaseException,
									RemoteException;
									
									 
import java.io.IOException;
import java.sql.SQLException;
import javax.naming.NamingException;
import javax.jms.JMSException;
import javax.ejb.CreateException;
import java.net.MalformedURLException;
import javax.ejb.FinderException;

import com.choicemaker.cm.server.base.InvalidModelException;
import com.choicemaker.cm.server.base.DatabaseException;
									   
*/
