/*
 * RecordMatcher.java       Revision: 2.5  Date: Jun 28, 2005 9:41:18 AM 
 *
 * Copyright (c) 2001 ChoiceMaker Technologies, Inc.
 * 48 Wall Street, 11th Floor, New York, NY 10005
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * ChoiceMaker Technologies Inc. ("Confidential Information").
 */
package com.choicemaker.cm.urm.cmcherel;

import java.rmi.RemoteException;

import javax.ejb.EJBObject;

import com.choicemaker.cm.urm.base.DbRecordCollection;
import com.choicemaker.cm.urm.base.EvaluatedRecord;
import com.choicemaker.cm.urm.base.ISingleRecord;
import com.choicemaker.cm.urm.exceptions.ArgumentException;
import com.choicemaker.cm.urm.exceptions.CmRuntimeException;
import com.choicemaker.cm.urm.exceptions.ConfigException;
import com.choicemaker.cm.urm.exceptions.ModelException;
import com.choicemaker.cm.urm.exceptions.RecordCollectionException;
import com.choicemaker.cm.urm.exceptions.RecordException;


/**
 * Allows a client application to find all records matching (evaluated as MATCH or HOLD ) with the specified record in online (synchronous) mode 
 * and executes further analysis of the obtained set of records to identify the subsets that are most likely linked together; 
 * the linked records are normally denote the same physical entity and are recommended for merging.
 * <p>
 * The below example demonstrates how the <code>getCompositeMatchCandidates</code> would be invoked within the client application.
 * <p>
 * As the query record it passes a record holder. A record holder is a class that stores actual record data as values of it's member variables. 
 * Record holders are customer specific classes and generated from the customer's ChoiceMaker schema which is a part of the matching model.
 * Customer specific record holder clases are derived from the <code>IRecordHolder</code> interface that is derived from <code>ISingleRecord</code>.  
 * Record holders are included into the deployment package as part of the models.jar library. Another type of a
 * record that could be passed as the query is <code>GlobalRecordRef</code>. It represents a reference to a record and
 * doesn't contain actual data at runtime.
 * <p>
 * As the master record collection it passes a database record collection (an instance of <code>DbRecordCollection</code>).
 * The <code>DbRecordCollection</code> is a reference to a record collection located in a database.
 * Database is defined by the URL and the record collection by the DB configuration name. DB Configuration defines a set ChoiceMaker 
 * specific views that implement the mapping from the actual customer tables into the ChoiceMaker matching model record structure defined by
 * the ChoiceMaker schema ( .schema file).   
 * <p>
 * For more details regarding record classes and record collection classes 
 * please see the <code>com.choicemaker.cm.urm.base</code> package. For more details regarding the ChoiceMakel model, schema and
 * DB configuration please see ChoiceMaker User Guide.
 * <p>
 * <p>
 * <pre>
 * InitialContext initialContext = new InitialContext();
 * Object queryHomeRef = initialContext.lookup("java:comp/env/ejb/OnlineMatchAnalyzer");
 * OnlineMatchAnalyzerHome qsh = 
 * (OnlineMatchAnalyzerHome)PortableRemoteObject.narrow(queryHomeRef, OnlineMatchAnalyzerHome.class);
 * OnlineMatchAnalyzer qs = qsh.create();
 * PatientHolder ph = new PatientHolder();
 *      
 * 	NamesHolder nh = new NamesHolder();
 *	nh.setFirst_name("John");
 *	nh.setLast_name("Brown");
 *	ph.setNames(new NamesHolder[]{nh});
 * 
 *  DbRecordCollection masterCollection = new DbRecordCollection("services:jndi://java:/OABADS","cmt");
 *		
 * String modelName = "onlineMatch";
 *     
 * EvaluatedRecord[] mc = qs.getCompositeMatchCandidates(ph, 
 *                                                       masterCollection,
 *                                                       modelName, 
 *				  										 confName,
 *                                                       "test");
 * for(int n=0; n &lt; mc.length; n++){    	
 *    IRecord r = mc[n].getRecord();
 *    if( r instanceof LinkedRecordSet){
 *    	System.out.println ("Linked Record Set: \n");
 * 		CompositeRecord lrs = (CompositeRecord)r;
 * 		for (int i = 0; i &lt; lrs.getRecords().length; i++) {    	        	
 * 		   MatchScore rs = ((CompositeMatchScore)mc[n].getScore()).getInnerScores()[i];
 * 		   System.out.println ("Record ID: "+lrs.getRecords()[i].getId()+
 *                            " Decision: "+rs.getDecision()+
 * 						      " Prob: "+rs.getProbability()+"\n");
 * 		} 		
 * 	  }
 *    else{
 * 		MatchScore rs = (MatchScore)mc[n].getScore();
 *      System.out.println ("Single record: "+ r.getId()+
 * 						    " Decision: "+rs.getDecision()+
 *         					" Prob: "+rs.getProbability()+"\n");
 *    }
 * }
 * </pre>
 * <p>
 * Each EvaluatedRecord of the returned array consists of a matched record and a score that reflects the probability of the match.
 * In the contrast to the result of the <code>getMatchCandidates</code> method each returned evaluated record could be either a composite record or a single recors.
 * Each returned composite records includes records that most likely represent a unique entity and are recommended for merging.  
 * If a link criteria provided by the named configuration requires such "merge" record set to include the query record then the resulting array will include no more then 
 * one composite record. Otherwise it is possible that the result will include more then one composite record.
 *      
 * 
 * @author emoussikaev
 * @version Revision: 2.5  Date: Jun 28, 2005 2:40:13 PM
 * @see
 */
public interface RealtimeMatchAnalyzer extends EJBObject {
	
	/**
	 * Finds all records from the master record collection <code>mRc</code> that are evaluated
	 * as a MATCH or HOLD to the query record <code>queryRecord</code>. Then it analyzes those records to extract
	 * sets of records that are tightly connected together my match/hold relationships. 
	 * The exact meaning of being �tightly connected together� is defined by the link criteria provided by the named configuration.
	 * Records placed in one group are recommended for merging. The result array of evaluated record
	 * includes extracted<code>CompositeRecords</code> as well as the rest single records that were not included into
	 * any composite record. Each evaluated record includes match score to the query record. 
	 * Array is ordered by the match probability. 
	 * 
	 * @param queryRecord query record
	 * @param mRc a master record collection.
	 * @param confName	the name of the configuration that stores the matching process parameters.
	 * @param trackingId an arbitrary string that is stored and may be used for later reporting.
	 *  
	 * @return an array of evaluated records
	 * 
	 * @throws ModelException
	 * @throws RecordException
	 * @throws RecordCollectionException
	 * @throws ConfigException
	 * @throws CmRuntimeException
	 * @throws RemoteException
	 */
	  public EvaluatedRecord[]	  getCompositeMatchCandidates(
									ISingleRecord queryRecord, 
									DbRecordCollection mRc,
									String confName, 
									String externalId) 
								throws 	ArgumentException,
										ModelException, 	
										RecordException,
										RecordCollectionException,
										ConfigException,
										CmRuntimeException, 
										RemoteException;
										
	/**
	 * Finds all records from the master record collection <code>mRc</code> that are evaluated
	 * as a MATCH or HOLD to the query record <code>queryRecord</code>. Then it analyzes those records to extract
	 * sets of records that are tightly connected together my match/hold relationships. 
	 * The exact meaning of being �tightly connected together� is defined by the link criteria <code>c</code> provided by the named configuration.
	 * Records placed in one group are recommended for merging. The result array of evaluated record
	 * includes extracted<code>CompositeRecords</code> as well as the rest single records that were not included into
	 * any composite record. Each evaluated record includes match score to the query record. 
	 * Array is ordered by the match probability. 
	 * f any of the parameters is provided by the <code>overrideProps</code> it replaces the corresponding parameter from the named configuration.
	 * 
	 * @param queryRecord query record
	 * @param mRc a master record collection.
	 * @param confName	the name of the configuration that stores the matching process parameters.
	 * @param  overrideProps set of matching process parameters that replace the parameters defined by the named configuration.
	 * @param trackingId an arbitrary string that is stored and may be used for later reporting.
	 *  
	 * @return an array of evaluated records
	 * 
	 * @throws ModelException
	 * @throws RecordException
	 * @throws RecordCollectionException
	 * @throws ConfigException
	 * @throws CmRuntimeException
	 * @throws RemoteException
	 */										
	public EvaluatedRecord[]	  getCompositeMatchCandidates(
									  ISingleRecord queryRecord, 
									  DbRecordCollection mRc,
									  String confName, 
									  CmConfiguration overrideProps,
									  String externalId) 
								  throws 	ArgumentException,
										  ModelException, 	
										  RecordException,
										  RecordCollectionException,
										  ConfigException,
										  CmRuntimeException, 
										  RemoteException;								
	/**
	 * Returns the version of the interface implementation.
	 * <p> 
	 * 
	 * @param context reserved
	 * @return version
	 * @throws RemoteException
	 */

	public String	getVersion(
						Object context
					)
					throws  RemoteException;							
						
										
}




