/*******************************************************************************
 * Copyright (c) 2015 ChoiceMaker LLC and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package com.choicemaker.cm.io.blocking.exact.base.gen;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.jdom2.Attribute;
import org.jdom2.Element;

import com.choicemaker.cm.core.Constants;
import com.choicemaker.cm.core.DerivedSource;
import com.choicemaker.cm.core.gen.CoreTags;
import com.choicemaker.cm.core.gen.GenException;
import com.choicemaker.cm.core.gen.GeneratorHelper;
import com.choicemaker.cm.core.gen.IGenerator;
import com.choicemaker.cm.io.blocking.base.gen.BlockingTags;

/**
 * Description
 * 
 * @author  Martin Buechi
 */
public class BlockingConfigurationGenerator {
	IGenerator g;
	String name;
	String className;
	Element blockingGlobal;
	Writer w;
	Set usedRecords;
	boolean generated;
	DerivedSource conf;
	SortedSet blockingFields = new TreeSet();
	Writer tw;

	public BlockingConfigurationGenerator(IGenerator g, String name, Element blockingGlobal) throws GenException, IOException {
		this.g = g;
		this.name = name;
		this.className = g.getSchemaName() + "__" + name + "__ExactBlocker";
		this.blockingGlobal = blockingGlobal;
		this.conf = DerivedSource.valueOf(name);
		generated = true;
		generate();
	}

	private void generate() throws IOException, GenException {
		String directoryName = g.getSourceCodePackageRoot() + File.separator + "blocking";
		String fileName = directoryName + File.separator + className + ".java";
		g.addGeneratedFile(fileName);
		FileOutputStream fs = new FileOutputStream(new File(fileName).getAbsoluteFile());
		w = new OutputStreamWriter(new BufferedOutputStream(fs));
		w.write("// Generated by ChoiceMaker. Do not edit." + Constants.LINE_SEPARATOR);
		String packageName = g.getPackage() + ".blocking";
		w.write("package " + packageName + ";" + Constants.LINE_SEPARATOR);
		w.write("import java.util.logging.*;" + Constants.LINE_SEPARATOR);
		w.write("import java.util.*;" + Constants.LINE_SEPARATOR);
		w.write("import com.choicemaker.cm.core.*;" + Constants.LINE_SEPARATOR);
		w.write("import com.choicemaker.cm.core.base.*;" + Constants.LINE_SEPARATOR);
		w.write("import com.choicemaker.cm.io.blocking.exact.base.*;" + Constants.LINE_SEPARATOR);
		w.write("import " + g.getPackage() + ".*;" + Constants.LINE_SEPARATOR);
		w.write(g.getImports());
		w.write("public final class " + className + " extends ExactInMemoryBlocker {" + Constants.LINE_SEPARATOR);
		w.write("private static Logger logger = Logger.getLogger(" + packageName + "." + className + ".class.getName());" + Constants.LINE_SEPARATOR);
		w.write("public " + className + "(PositionMap positionMap) {" + Constants.LINE_SEPARATOR);
		w.write("super(positionMap);" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write("protected List getSourceKeys(Object rr) {" + Constants.LINE_SEPARATOR);
		writeHead(w);
		traverseAndWriteSource(g.getRootRecord(), 0);
		writeTail(w);
		writeTarget();
		writeKey();
		w.write("}" + Constants.LINE_SEPARATOR);
		w.close();
		fs.close();
	}

	private void writeHead(Writer wx) throws IOException {
		String cn = g.getRootRecord().getAttributeValue(CoreTags.CLASS_NAME);
		wx.write(cn + " r0 = (" + cn + ")rr;" + Constants.LINE_SEPARATOR);
		wx.write("Key firstKey = new Key();" + Constants.LINE_SEPARATOR);
	}

	private void traverseAndWriteSource(Element r, int level) throws IOException {
		Collection bfsl = getBlockingFields(r);
		for (Iterator iBfsl = bfsl.iterator(); iBfsl.hasNext();) {
			List bfl = (List) iBfsl.next();
			Element[] bfs = (Element[]) bfl.toArray(new Element[bfl.size()]);
			writeNodeType(r, level, bfs, null);
		}
		if (level == 0) {
			writePreStacked(w);
		}
		List records = r.getChildren(CoreTags.NODE_TYPE);
		for (Iterator iRecords = records.iterator(); iRecords.hasNext();) {
			traverseAndWriteSource((Element) iRecords.next(), level + 1);
		}
	}

	private void writeTarget() throws IOException {
		w.write("protected List getTargetKeys(Object rr) {" + Constants.LINE_SEPARATOR);
		writeHead(w);
		List l = new ArrayList();
		int rn = 0;
		String tg = "";
		boolean wrotePreStacked = false;
		for (Iterator iBlockingField = blockingFields.iterator(); iBlockingField.hasNext();) {
			Field targetField = (Field) iBlockingField.next();
			if (rn != targetField.targetRecordNumber || tg != targetField.targetGroup) {
				if (!l.isEmpty()) {
					wrotePreStacked = processList(l, rn, wrotePreStacked);
					l.clear();
				}
				rn = targetField.targetRecordNumber;
				tg = targetField.targetGroup;
			}
			l.add(targetField);
		}
		if (!l.isEmpty()) {
			processList(l, 1, wrotePreStacked);
		}
		writeTail(w);
	}

	private boolean processList(List l, int rn, boolean wrotePreStacked) throws IOException {
		if (rn != 0 && !wrotePreStacked) {
			writePreStacked(w);
			wrotePreStacked = true;
		}
		Field[] targetFields = (Field[]) l.toArray(new Field[l.size()]);
		Element[] bfs = new Element[targetFields.length];
		for (int i = 0; i < bfs.length; i++) {
			bfs[i] = targetFields[i].bf;
		}
		Element fieldNodeType = targetFields[0].targetField.getParentElement();
		int level = Integer.parseInt(fieldNodeType.getAttributeValue(CoreTags.LEVEL));
		writeNodeType(fieldNodeType, level, bfs, targetFields);
		if (rn == 0) {
			writePreStacked(w);
			wrotePreStacked = true;
		}
		return wrotePreStacked;
	}
	/**
	 * Method writeList.
	 * @param l
	 */
	private void writeNodeType(Element fieldNodeType, int level, Element[] bfs, Field[] targetFields) throws IOException {
		if (level != 0) {
			writePreGroup(w);
			String fors = "";
			Element cur = fieldNodeType;
			for (int i = 0; i < level; i++) {
				int curl = level - i;
				String name = cur.getAttributeValue(CoreTags.NAME);
				fors =
					"for(int i"
						+ curl
						+ " = 0; i"
						+ curl
						+ " < r"
						+ (curl - 1)
						+ "."
						+ name
						+ ".length; ++i"
						+ curl
						+ ") {"
						+ Constants.LINE_SEPARATOR
						+ cur.getAttributeValue(CoreTags.CLASS_NAME)
						+ " r"
						+ curl
						+ " = r"
						+ (curl - 1)
						+ "."
						+ name
						+ "[i"
						+ curl
						+ "];"
						+ Constants.LINE_SEPARATOR
						+ fors;
				cur = cur.getParentElement();
			}
			w.write(fors);
		}
		w.write("if(");
		for (int i = 0; i < bfs.length; i++) {
			Element bf = bfs[i];
			if (i != 0) {
				w.write(" &&");
			}
			Element f = targetFields == null ? bf.getParentElement() : targetFields[i].targetField;
			w.write("r" + level + ".__v_" + f.getAttributeValue(CoreTags.NAME));
			String valid = bf.getAttributeValue(targetFields != null ? BlockingTags.TARGET_VALID : BlockingTags.SOURCE_VALID);
			if (valid != null) {
				w.write(" && " + valid);
			}
		}
		w.write(") { " + Constants.LINE_SEPARATOR);
		String keyName;
		if (level == 0) {
			keyName = "firstKey";
		} else {
			w.write("for (int j = 0; j < size; ++j) {" + Constants.LINE_SEPARATOR);
			w.write("Key k = (Key) l.get(j);" + Constants.LINE_SEPARATOR);
			w.write("if (!first) {" + Constants.LINE_SEPARATOR);
			w.write("l.add(k.clone());" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			keyName = "k";
		}
		for (int i = 0; i < bfs.length; i++) {
			Element bf = bfs[i];
			Element f = bf.getParentElement();
			String name = targetFields == null ? f.getAttributeValue(CoreTags.NAME) : targetFields[i].targetField.getAttributeValue(CoreTags.NAME);
			String keyFieldName = getKeyFieldName(f);
			if (targetFields == null) {
				blockingFields.add(new Field(keyFieldName, f.getAttributeValue(CoreTags.TYPE), bf));
			}
			w.write(keyName + "." + keyFieldName + " = r" + level + "." + name + ";" + Constants.LINE_SEPARATOR);
		}
		if (level == 0) {
			w.write("} else {" + Constants.LINE_SEPARATOR);
			w.write("return EMPTY_LIST;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
		} else {
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("first = false;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			for (int i = 0; i < level; i++) {
				w.write("}" + Constants.LINE_SEPARATOR);
			}
			w.write("if (first) {" + Constants.LINE_SEPARATOR);
			w.write("return EMPTY_LIST;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
		}
	}

	private Collection getBlockingFields(Element r) {
		int recordNumber = Integer.parseInt(r.getAttributeValue(CoreTags.RECORD_NUMBER));
		HashMap map = new HashMap();
		List fields = r.getChildren("field");
		Iterator iFields = fields.iterator();
		while (iFields.hasNext()) {
			Element f = (Element) iFields.next();
			Iterator iBlockingFields = f.getChildren(BlockingTags.BLOCKING_FIELD).iterator();
			boolean first = true;
			while (iBlockingFields.hasNext()) {
				Element bf = (Element) iBlockingFields.next();
				if (GeneratorHelper.includesConf(bf, conf) && GeneratorHelper.getBooleanAttribute(bf, CoreTags.USE, true)) {
					if (!first) {
						g.error("Can only use source field once.");
					}
					String sourceGroup = getGroup(bf, BlockingTags.SOURCE_GROUP, recordNumber);
					List l = (List) map.get(sourceGroup);
					if (l == null) {
						l = new ArrayList();
						map.put(sourceGroup, l);
					}
					l.add(bf);
					first = false;
				}
			}
		}
		return map.values();
	}

	private void writeTail(Writer wx) throws IOException {
		wx.write("return l;" + Constants.LINE_SEPARATOR);
		wx.write("}" + Constants.LINE_SEPARATOR);
	}

	private void writePreStacked(Writer wx) throws IOException {
		wx.write("List l = new ArrayList();" + Constants.LINE_SEPARATOR);
		wx.write("l.add(firstKey);" + Constants.LINE_SEPARATOR);
		wx.write("int size;" + Constants.LINE_SEPARATOR);
		wx.write("boolean first;" + Constants.LINE_SEPARATOR);
	}

	private void writePreGroup(Writer wx) throws IOException {
		wx.write("size = l.size();" + Constants.LINE_SEPARATOR);
		wx.write("first = true;" + Constants.LINE_SEPARATOR);
	}

	private String getKeyFieldName(Element e) {
		return e.getParentElement().getAttributeValue(CoreTags.CLASS_NAME) + "__" + e.getAttributeValue(CoreTags.NAME);
	}

	private void writeKey() throws IOException {
		w.write("private static class Key implements Cloneable {" + Constants.LINE_SEPARATOR);
		Field[] fs = (Field[]) blockingFields.toArray(new Field[blockingFields.size()]);
		for (int i = 0; i < fs.length; i++) {
			w.write(fs[i].type + " " + fs[i]._name + ";" + Constants.LINE_SEPARATOR);
		}
		w.write("public int hashCode() {" + Constants.LINE_SEPARATOR);
		w.write("return ");
		for (int i = 1; i < fs.length; i++) {
			w.write("~(");
		}
		for (int i = 0; i < fs.length; i++) {
			Field f = fs[i];
			if (i != 0) {
				w.write(" ^ ");
			}
			if (GeneratorHelper.isPrimitiveType(f.type)) {
				w.write("(int)" + f._name);
			} else {
				w.write("(" + f._name + " == null ? 0 : " + f._name + ".hashCode())");
			}
			if (i != fs.length - 1) {
				w.write(")");
			}
		}
		w.write(";" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write("public boolean equals(Object o) {" + Constants.LINE_SEPARATOR);
		w.write("Key k = (Key) o;" + Constants.LINE_SEPARATOR);
		w.write("return ");
		for (int i = 0; i < fs.length; i++) {
			if (i != 0) {
				w.write(" && ");
			}
			w.write("(");
			w.write(GeneratorHelper.compareField(fs[i]._name, "k." + fs[i]._name, fs[i].type, g.isIntern(), true));
			w.write(")");
		}
		w.write(";" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write("public Object clone() {" + Constants.LINE_SEPARATOR);
		w.write("try {" + Constants.LINE_SEPARATOR);
		w.write("return super.clone();" + Constants.LINE_SEPARATOR);
		w.write("} catch (CloneNotSupportedException ex) {" + Constants.LINE_SEPARATOR);
		w.write("return null;" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
	}

	private String getGroup(Element blockingField, String attributeName, int recordNumber) {
		String group = "";
		Attribute groupAttribute = blockingField.getAttribute(attributeName);
		if (groupAttribute != null) {
			if (recordNumber == 0) {
				g.warning("Group ignored for non-stacked records.");
			} else {
				group = groupAttribute.getValue().intern();
			}
		}
		return group;
	}

	private class Field implements Comparable {
		String _name;
		String type;
		Element bf;
		int targetRecordNumber;
		String targetGroup;
		Element targetField;
		Field(String name, String type, Element bf) {
			this._name = name;
			this.type = type;
			this.bf = bf;
			init();
		}

		private void init() {
			String targetNodeTypeName = bf.getAttributeValue(BlockingTags.TARGET_NODE_TYPE_NAME);
			String targetFieldName = bf.getAttributeValue(BlockingTags.TARGET_FIELD_NAME);
			if (targetNodeTypeName == null) {
				if (targetFieldName == null) {
					targetField = bf.getParentElement();
				} else {
					targetField = GeneratorHelper.findField(bf.getParentElement().getParentElement(), targetFieldName);
				}
			} else {
				Element targetNodeType = GeneratorHelper.findNodeType(g.getRootElement(), targetNodeTypeName);
				if (targetNodeType != null) {
					targetField =
						GeneratorHelper.findField(targetNodeType, targetFieldName == null ? bf.getParentElement().getAttributeValue(CoreTags.NAME) : targetFieldName);
				}
			}
			if (targetField == null) {
				g.error("Unknown target field.");
			} else if (!bf.getParentElement().getAttributeValue(CoreTags.TYPE).equals(targetField.getAttributeValue(CoreTags.TYPE))) {
				g.error("Incompatible types.");
			} else {
				targetRecordNumber = Integer.parseInt(targetField.getParentElement().getAttributeValue(CoreTags.RECORD_NUMBER));
			}
			targetGroup = getGroup(bf, BlockingTags.TARGET_GROUP, targetRecordNumber);
		}

		public int compareTo(Object o) {
			Field f = (Field) o;
			if (targetRecordNumber < f.targetRecordNumber) {
				return -1;
			} else if (targetRecordNumber > f.targetRecordNumber) {
				return 1;
			} else {
				int res = targetGroup.compareTo(f.targetGroup);
				if (res != 0) {
					return res;
				} else {
					return targetField.getAttributeValue(CoreTags.NAME).compareTo(f.targetField.getAttributeValue(CoreTags.NAME));
				}
			}
		}
	}
}
