// Generated by ChoiceMaker. Do not edit.
package com.choicemaker.cm.custom.mci.gend.internal.MciRecords;
import com.choicemaker.cm.core.*;
import com.choicemaker.cm.core.base.*;
import com.choicemaker.cm.core.util.*;
import com.choicemaker.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import javax.swing.JLabel;
import com.choicemaker.util.StringUtils;
import com.choicemaker.cm.custom.mci.encryption.*;
import com.choicemaker.cm.custom.mci.matching.*;
import com.choicemaker.cm.custom.mci.nameparser.*;
import com.choicemaker.cm.custom.mci.validation.*;
import com.choicemaker.cm.matching.en.*;
import com.choicemaker.cm.matching.en.us.*;
import com.choicemaker.cm.matching.gen.*;
import com.choicemaker.cm.validation.eclipse.*;
import com.choicemaker.cm.validation.eclipse.impl.*;
import java.util.*;
public class NamesImpl____descriptor implements com.choicemaker.cm.core.Descriptor {
public static com.choicemaker.cm.core.Descriptor instance = new NamesImpl____descriptor();
private static HashMap m;
private static ColumnDefinition[] cols = {
new ColumnDefinition("First name", "first_name", 100, JLabel.CENTER),
new ColumnDefinition("Middle name", "middle_name", 100, JLabel.CENTER),
new ColumnDefinition("last_name", "last_name", 100, JLabel.CENTER),
new ColumnDefinition("< sound_first_name >", "sound_first_name", 100, JLabel.CENTER),
new ColumnDefinition("< sound_last_name >", "sound_last_name", 100, JLabel.CENTER),
new ColumnDefinition("< nameF >", "nameF", 100, JLabel.CENTER),
new ColumnDefinition("< nameM >", "nameM", 100, JLabel.CENTER),
new ColumnDefinition("< nameL >", "nameL", 100, JLabel.CENTER),
new ColumnDefinition("< nameMaidn >", "nameMaidn", 100, JLabel.CENTER),
new ColumnDefinition("< nameT >", "nameT", 100, JLabel.CENTER),
new ColumnDefinition("< mothersFirstName >", "mothersFirstName", 100, JLabel.CENTER),
new ColumnDefinition("< multiBirthOrder >", "multiBirthOrder", 100, JLabel.CENTER),
new ColumnDefinition("dob", "dob", 100, JLabel.CENTER),
new ColumnDefinition("< dob_y_m >", "dob_y_m", 100, JLabel.CENTER),
new ColumnDefinition("< dobNumbers >", "dobNumbers", 100, JLabel.CENTER),
new ColumnDefinition("sex_cd", "sex_cd", 100, JLabel.CENTER),
new ColumnDefinition("< clean_sex >", "clean_sex", 100, JLabel.CENTER),
new ColumnDefinition("facility_id", "facility_id", 100, JLabel.CENTER)};
private static com.choicemaker.cm.core.Descriptor[] children = {
};
public boolean[] getEditable(DerivedSource src) {
return new boolean[] {
true,
true,
true,
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
!__src1.includes(src),
true,
!__src1.includes(src),
!__src1.includes(src),
true,
!__src1.includes(src),
true};
}
private static DerivedSource __src1 = DerivedSource.valueOf("all");
public String getName() {
return "Names";
}
public String getRecordName() {
return "names";
}
public boolean isStackable() {
return true;
}
public ColumnDefinition[] getColumnDefinitions() {
return cols;
}
public Descriptor[] getChildren() {
return children;
}
public Record[][] getChildRecords(Record ri) {
return null;
}
public String getValueAsString(Record ri, int row, int col) {
PatientImpl r0 = (PatientImpl)ri;
int cur = 0;
if(cur + r0.names.length <= row) {
cur += r0.names.length;
} else {
switch(col) {
case 0:
return r0.names[row-cur].first_name;
case 1:
return r0.names[row-cur].middle_name;
case 2:
return r0.names[row-cur].last_name;
case 3:
return r0.names[row-cur].sound_first_name;
case 4:
return r0.names[row-cur].sound_last_name;
case 5:
return r0.names[row-cur].nameF;
case 6:
return r0.names[row-cur].nameM;
case 7:
return r0.names[row-cur].nameL;
case 8:
return r0.names[row-cur].nameMaidn;
case 9:
return r0.names[row-cur].nameT;
case 10:
return r0.names[row-cur].mothersFirstName;
case 11:
return String.valueOf(r0.names[row-cur].multiBirthOrder);
case 12:
return r0.names[row-cur].dob == null ? null : DateHelper.formatDisplay(r0.names[row-cur].dob);
case 13:
return r0.names[row-cur].dob_y_m;
case 14:
return String.valueOf(r0.names[row-cur].dobNumbers);
case 15:
return r0.names[row-cur].sex_cd == '\0' ? "" : String.valueOf(r0.names[row-cur].sex_cd);
case 16:
return r0.names[row-cur].clean_sex == '\0' ? "" : String.valueOf(r0.names[row-cur].clean_sex);
case 17:
return r0.names[row-cur].facility_id;
default:
throw new IndexOutOfBoundsException();
}
}
throw new IndexOutOfBoundsException();
}
public Object getValue(Record ri, int row, int col) {
PatientImpl r0 = (PatientImpl)ri;
int cur = 0;
if(cur + r0.names.length <= row) {
cur += r0.names.length;
} else {
switch(col) {
case 0:
return r0.names[row-cur].first_name;
case 1:
return r0.names[row-cur].middle_name;
case 2:
return r0.names[row-cur].last_name;
case 3:
return r0.names[row-cur].sound_first_name;
case 4:
return r0.names[row-cur].sound_last_name;
case 5:
return r0.names[row-cur].nameF;
case 6:
return r0.names[row-cur].nameM;
case 7:
return r0.names[row-cur].nameL;
case 8:
return r0.names[row-cur].nameMaidn;
case 9:
return r0.names[row-cur].nameT;
case 10:
return r0.names[row-cur].mothersFirstName;
case 11:
return new Integer(r0.names[row-cur].multiBirthOrder);
case 12:
return r0.names[row-cur].dob;
case 13:
return r0.names[row-cur].dob_y_m;
case 14:
return new Integer(r0.names[row-cur].dobNumbers);
case 15:
return new Character(r0.names[row-cur].sex_cd);
case 16:
return new Character(r0.names[row-cur].clean_sex);
case 17:
return r0.names[row-cur].facility_id;
default:
throw new IndexOutOfBoundsException();
}
}
throw new IndexOutOfBoundsException();
}
public Class getHandledClass() {
return NamesImpl.class;
}
public boolean setValue(Record ri, int row, int col, String value) {
try {
PatientImpl r0 = (PatientImpl)ri;
int cur = 0;
if(cur + r0.names.length <= row) {
cur += r0.names.length;
} else {
switch(col) {
case 0:
r0.names[row-cur].first_name = value;
break;
case 1:
r0.names[row-cur].middle_name = value;
break;
case 2:
r0.names[row-cur].last_name = value;
break;
case 3:
r0.names[row-cur].sound_first_name = value;
break;
case 4:
r0.names[row-cur].sound_last_name = value;
break;
case 5:
r0.names[row-cur].nameF = value;
break;
case 6:
r0.names[row-cur].nameM = value;
break;
case 7:
r0.names[row-cur].nameL = value;
break;
case 8:
r0.names[row-cur].nameMaidn = value;
break;
case 9:
r0.names[row-cur].nameT = value;
break;
case 10:
r0.names[row-cur].mothersFirstName = value;
break;
case 11:
r0.names[row-cur].multiBirthOrder = value.length() == 0 ? (int)0 : Integer.parseInt(value);
break;
case 12:
r0.names[row-cur].dob = DateHelper.parse(value);
break;
case 13:
r0.names[row-cur].dob_y_m = value;
break;
case 14:
r0.names[row-cur].dobNumbers = value.length() == 0 ? (int)0 : Integer.parseInt(value);
break;
case 15:
r0.names[row-cur].sex_cd = value.length() == 0 ? (char)0 : StringUtils.getChar(value);
break;
case 16:
r0.names[row-cur].clean_sex = value.length() == 0 ? (char)0 : StringUtils.getChar(value);
break;
case 17:
r0.names[row-cur].facility_id = value;
break;
default:
throw new IndexOutOfBoundsException();
}
return true;}
throw new IndexOutOfBoundsException();
} catch(Exception ex) {
return false;
}
}
public boolean getValidity(Record ri, int row, int col) {
PatientImpl r0 = (PatientImpl)ri;
int cur = 0;
if(cur + r0.names.length <= row) {
cur += r0.names.length;
} else {
switch(col) {
case 0:
return r0.names[row-cur].__v_first_name;
case 1:
return r0.names[row-cur].__v_middle_name;
case 2:
return r0.names[row-cur].__v_last_name;
case 3:
return r0.names[row-cur].__v_sound_first_name;
case 4:
return r0.names[row-cur].__v_sound_last_name;
case 5:
return r0.names[row-cur].__v_nameF;
case 6:
return r0.names[row-cur].__v_nameM;
case 7:
return r0.names[row-cur].__v_nameL;
case 8:
return r0.names[row-cur].__v_nameMaidn;
case 9:
return r0.names[row-cur].__v_nameT;
case 10:
return r0.names[row-cur].__v_mothersFirstName;
case 11:
return r0.names[row-cur].__v_multiBirthOrder;
case 12:
return r0.names[row-cur].__v_dob;
case 13:
return r0.names[row-cur].__v_dob_y_m;
case 14:
return r0.names[row-cur].__v_dobNumbers;
case 15:
return r0.names[row-cur].__v_sex_cd;
case 16:
return r0.names[row-cur].__v_clean_sex;
case 17:
return r0.names[row-cur].__v_facility_id;
default:
throw new IndexOutOfBoundsException();
}
}
throw new IndexOutOfBoundsException();
}
public void addRow(int row, boolean above, Record ri) {
PatientImpl r0 = (PatientImpl)ri;
if(!above) {
++row;
};
int cur = 0;
if(cur + r0.names.length < row || (above && cur + r0.names.length == row && row != 0)) {
cur += r0.names.length;
} else {
NamesImpl[] tmp = new NamesImpl[r0.names.length + 1];
System.arraycopy(r0.names, 0, tmp, 0, (row - cur));
tmp[(row - cur)] = NamesImpl.instance();
System.arraycopy(r0.names, (row - cur), tmp, (row - cur) + 1, tmp.length - 1 - (row - cur));
r0.names = tmp;
return;}
throw new IndexOutOfBoundsException();
}
public void deleteRow(Record ri, int row) {
PatientImpl r0 = (PatientImpl)ri;
int cur = 0;
if(cur + r0.names.length <= row) {
cur += r0.names.length;
} else {
NamesImpl[] tmp = new NamesImpl[r0.names.length - 1];
System.arraycopy(r0.names, 0, tmp, 0, (row - cur));
System.arraycopy(r0.names, (row - cur) + 1, tmp, (row - cur), tmp.length - (row - cur));
r0.names = tmp;
return;}
throw new IndexOutOfBoundsException();
}
public int getColumnCount() {
return cols.length;
}
public int getRowCount(Record ri) {
PatientImpl r0 = (PatientImpl)ri;
int num = 0;
num += r0.names.length;
return num;
}

public int getColumnIndexByName(String name) {
if(m == null) {
m = new HashMap(cols.length);
for(int i = 0; i < cols.length; ++i) {
m.put(cols[i].getFieldName(), new Integer(i));
}
}
Object o = m.get(name);
if(o == null) {
return -1;
} else {
return ((Integer)o).intValue();
}
}
}
