/*
 * Copyright (c) 2001, 2009 ChoiceMaker Technologies, Inc. and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License
 * v1.0 which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     ChoiceMaker Technologies, Inc. - initial API and implementation
 */
package com.choicemaker.cm.io.flatfile.base.gen;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.jdom.Element;

import com.choicemaker.cm.core.util.StringUtils;
import com.choicemaker.cm.core.base.Constants;
import com.choicemaker.cm.core.base.DerivedSource;
import com.choicemaker.cm.core.gen.CoreTags;
import com.choicemaker.cm.core.gen.GenException;
import com.choicemaker.cm.core.gen.IGenerator;
import com.choicemaker.cm.core.gen.GeneratorHelper;
import com.choicemaker.cm.core.gen.GeneratorPlugin;
import com.choicemaker.cm.core.gen.GeneratorHelper.Id;

/**
 * Description
 *
 * @author    Martin Buechi
 * @version   $Revision: 1.1.1.1 $ $Date: 2009/05/03 16:02:58 $
 */
public class FlatFileMultiFileReaderGenerator implements GeneratorPlugin {
	private static DerivedSource src = DerivedSource.valueOf("flatfile");

	public static FlatFileMultiFileReaderGenerator instance = new FlatFileMultiFileReaderGenerator();

	private int recordNum;

	public void generate(IGenerator g) throws GenException {
		String className = g.getSchemaName() + "MultiFileFlatFileReader";
		String packageName = g.getPackage() + ".flatfile";
		g.addAccessorBody(
			"public Object getMultiFileFlatFileReader(Object tokenizer, boolean tagged) {"
				+ Constants.LINE_SEPARATOR);
		g.addAccessorBody(
			"return new " + packageName + "." + className + "((Tokenizer[])tokenizer, tagged);" + Constants.LINE_SEPARATOR);
		g.addAccessorBody("}" + Constants.LINE_SEPARATOR);
		try {
			String directoryName = g.getSourceCodePackageRoot() + File.separator + "flatfile";
			String fileName = directoryName + File.separator + className + ".java";
			g.addGeneratedFile(fileName);
			FileOutputStream fs = new FileOutputStream(new File(fileName).getAbsoluteFile());
			Writer w = new OutputStreamWriter(new BufferedOutputStream(fs));
			w.write("// Generated by ChoiceMaker. Do not edit." + Constants.LINE_SEPARATOR);
			w.write("package " + packageName + ";" + Constants.LINE_SEPARATOR);
			w.write("import org.apache.log4j.*;" + Constants.LINE_SEPARATOR);
			w.write("import java.util.*;" + Constants.LINE_SEPARATOR);
			w.write("import java.io.*;" + Constants.LINE_SEPARATOR);
			w.write("import com.choicemaker.cm.core.base.*;" + Constants.LINE_SEPARATOR);
			w.write("import com.choicemaker.cm.io.flatfile.base.*;" + Constants.LINE_SEPARATOR);
			w.write("import " + g.getPackage() + ".*;" + Constants.LINE_SEPARATOR);
			w.write(g.getImports());
			w.write("public final class " + className + " implements FlatFileReader {" + Constants.LINE_SEPARATOR);
			w.write(
				"private static Logger logger = Logger.getLogger("
					+ packageName
					+ "."
					+ className
					+ ".class);"
					+ Constants.LINE_SEPARATOR);
			w.write("private Tokenizer[] tokenizer;" + Constants.LINE_SEPARATOR);
			w.write("private boolean tagged;" + Constants.LINE_SEPARATOR);
			w.write(
				"private static DerivedSource src = DerivedSource.valueOf(\"flatfile\");" + Constants.LINE_SEPARATOR);
			Element rootRecord = g.getRootRecord();
			GeneratorHelper.multiFileFieldDeclarations(g, w, rootRecord, "flatfile", new LinkedList());
			w.write("public " + className + "(Tokenizer[] tokenizer, boolean tagged) {" + Constants.LINE_SEPARATOR);
			w.write("this.tokenizer = tokenizer;" + Constants.LINE_SEPARATOR);
			w.write("this.tagged = tagged;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public void open() throws IOException {" + Constants.LINE_SEPARATOR);
			callGetters(w, rootRecord);
			w.write("}" + Constants.LINE_SEPARATOR);
			w.write("public Record getRecord() throws IOException {" + Constants.LINE_SEPARATOR);
			String rootRecordClassName = rootRecord.getAttributeValue("className");
			w.write("Record __res = o__" + rootRecordClassName + ";" + Constants.LINE_SEPARATOR);
			w.write("__res.computeValidityAndDerived(src);" + Constants.LINE_SEPARATOR);
			w.write("getRecord" + rootRecordClassName + "();" + Constants.LINE_SEPARATOR);
			w.write("return __res;" + Constants.LINE_SEPARATOR);
			w.write("}" + Constants.LINE_SEPARATOR);
			recordNum = 0;
			writeGetters(g, w, rootRecord, true, new LinkedList());
			w.write("}" + Constants.LINE_SEPARATOR);
			w.flush();
			fs.close();
		} catch (IOException ex) {
			throw new GenException("Problem writing file.", ex);
		}
	}

	private void writeGetters(IGenerator g, Writer w, Element r, boolean root, LinkedList ids) throws IOException {
		++recordNum;
		String tokenizer = "tokenizer[" + recordNum + "]";
		String recordName = r.getAttributeValue("name");
		String className = r.getAttributeValue("className");
		w.write("private void getRecord" + className + "() throws IOException {" + Constants.LINE_SEPARATOR);
		Element hd = GeneratorHelper.getNodeTypeExt(r, "flatfile");
		String recordType = hd.getAttributeValue("tag");
		w.write("if(" + tokenizer + ".lineRead()) {" + Constants.LINE_SEPARATOR);
		w.write("if(tagged && " + tokenizer + ".tag != \"" + recordType + "\") {" + Constants.LINE_SEPARATOR);
		w.write("throw new IOException(\"Illegal tag: \" + " + tokenizer + ".tag);" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write(" o__" + className + " = new " + className + "();" + Constants.LINE_SEPARATOR);

		Iterator iL = ids.iterator();
		while (iL.hasNext()) {
			Id id = (Id) iL.next();
			w.write(className + "__" + id.name + " = ");
			getField(w, id.field, tokenizer, g.isIntern());
		}

		List fields = new ArrayList(r.getChildren("field"));
		int res = GeneratorHelper.filterFields(fields, src, "flatfileField");
		switch (res) {
			case GeneratorHelper.OK :
				break;
			case GeneratorHelper.DUPLICATE_POS :
				g.error(recordName + ": Duplicate pos");
				return;
			case GeneratorHelper.POS_OUTSIDE_RANGE :
				g.error(recordName + ": pos outside range");
				return;
		}
		Iterator iF = fields.iterator();
		while (iF.hasNext()) {
			Element field = (Element) iF.next();
			if (field == null) {
				w.write(tokenizer + ".skip(1);" + Constants.LINE_SEPARATOR);
			} else {
				w.write("o__" + className + "." + field.getAttributeValue("name") + " = ");
				getField(w, field, tokenizer, g.isIntern());
			}
		}
		w.write(tokenizer + ".readLine();" + Constants.LINE_SEPARATOR);
		List records = r.getChildren(CoreTags.NODE_TYPE);
		Id key = null;
		if (!records.isEmpty()) {
			key = GeneratorHelper.getId(g, r, "flatfile");
			if (key.field == null) {
				g.error("Node type " + recordName + " must have flatfile key field.");
				return;
			}
			Iterator iR = records.iterator();
			while (iR.hasNext()) {
				Element e = (Element) iR.next();
				String eClassName = e.getAttributeValue("className");
				w.write("while(o__" + eClassName + " != null");
				Iterator iI = ids.iterator();
				while (iI.hasNext()) {
					Id id = (Id) iI.next();
					w.write(
						" && "
							+ GeneratorHelper.compareField(
								className + "__" + id.name,
								eClassName + "__" + id.name,
								id.type,
								true));
				}
				w.write(
					" && "
						+ GeneratorHelper.compareField(
							"o__" + className + "." + key.name,
							eClassName + "__" + key.name,
							key.type,
							true));
				w.write(") {" + Constants.LINE_SEPARATOR);
				w.write("l__" + eClassName + ".add(o__" + eClassName + ");" + Constants.LINE_SEPARATOR);
				w.write("o__" + eClassName + ".outer = o__" + className + ";" + Constants.LINE_SEPARATOR);
				w.write("getRecord" + eClassName + "();" + Constants.LINE_SEPARATOR);
				w.write("}" + Constants.LINE_SEPARATOR);
				w.write("if(l__" + eClassName + ".size() == 0) {" + Constants.LINE_SEPARATOR);
				w.write(
					"o__"
						+ className
						+ "."
						+ e.getAttributeValue("name")
						+ " = "
						+ eClassName
						+ ".__zeroArray;"
						+ Constants.LINE_SEPARATOR);
				w.write("} else {" + Constants.LINE_SEPARATOR);
				w.write(
					"l__"
						+ eClassName
						+ ".toArray(o__"
						+ className
						+ "."
						+ e.getAttributeValue("name")
						+ " = new "
						+ eClassName
						+ "[l__"
						+ eClassName
						+ ".size()]);"
						+ Constants.LINE_SEPARATOR);
				w.write("l__" + eClassName + ".clear();" + Constants.LINE_SEPARATOR);
				w.write("}" + Constants.LINE_SEPARATOR);
			}
		}
		w.write("} else {" + Constants.LINE_SEPARATOR);
		w.write("o__" + className + " = null;" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		w.write("}" + Constants.LINE_SEPARATOR);
		if (!records.isEmpty()) {
			ids.add(key);
			Iterator iR = records.iterator();
			while (iR.hasNext()) {
				writeGetters(g, w, (Element) iR.next(), false, ids);
			}
			ids.removeLast();
		}
	}

	private void getField(Writer w, Element field, String tokenizer, boolean intern) throws IOException {
		int width = FlatFileGenerator.defaultWidth(field.getAttributeValue("type"));
		boolean trim = true;
		boolean valueOf = false;
		char nullRepresentation = FlatFileGenerator.DEFAULT_NULL_REPRESENTATION;
		int start = Integer.MIN_VALUE;
		Element fff = field.getChild("flatfileField");
		if (fff != null) {
			String t = fff.getAttributeValue("width");
			if (t != null) {
				width = Integer.parseInt(t);
			}
			t = fff.getAttributeValue(FlatFileTags.START);
			if (t != null) {
				start = Integer.parseInt(t);
			}
			trim = !"false".equals(fff.getAttributeValue("trim"));
			valueOf = "true".equals(fff.getAttributeValue("valueOf"));
			String nr = fff.getAttributeValue("nullRepresentation");
			if (nr != null) {
				nullRepresentation = StringUtils.getChar(nr);
			}
		}
		w.write(
			FlatFileGenerator.getField(
				tokenizer,
				field.getAttributeValue("type"),
				start,
				width,
				trim,
				valueOf,
				nullRepresentation,
				intern)
				+ ";"
				+ Constants.LINE_SEPARATOR);
	}

	private void callGetters(Writer w, Element r) throws IOException {
		List records = r.getChildren(CoreTags.NODE_TYPE);
		Iterator iR = records.iterator();
		while (iR.hasNext()) {
			callGetters(w, (Element) iR.next());
		}
		String className = r.getAttributeValue("className");
		w.write("getRecord" + className + "();" + Constants.LINE_SEPARATOR);
	}
}
