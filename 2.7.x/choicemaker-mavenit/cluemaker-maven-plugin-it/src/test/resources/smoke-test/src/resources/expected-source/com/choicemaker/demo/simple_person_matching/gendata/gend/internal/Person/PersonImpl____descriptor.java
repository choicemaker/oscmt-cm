// Generated by ChoiceMaker. Do not edit.
package com.choicemaker.demo.simple_person_matching.gendata.gend.internal.Person;
import com.choicemaker.client.api.*;
import com.choicemaker.cm.core.*;
import com.choicemaker.cm.core.base.*;
import com.choicemaker.cm.core.util.*;
import com.choicemaker.util.*;
import java.util.ArrayList;
import java.util.HashMap;
import javax.swing.JLabel;
import java.util.Date;
import com.choicemaker.util.StringUtils;
public class PersonImpl____descriptor implements com.choicemaker.cm.core.Descriptor {
public static com.choicemaker.cm.core.Descriptor instance = new PersonImpl____descriptor();
private static HashMap m;
private static ColumnDefinition[] cols = {
new ColumnDefinition("linkage_role", "linkage_role", 100, JLabel.CENTER),
new ColumnDefinition("entityId", "entityId", 100, JLabel.CENTER),
new ColumnDefinition("recordId", "recordId", 100, JLabel.CENTER),
new ColumnDefinition("ssn", "ssn", 100, JLabel.CENTER),
new ColumnDefinition("firstName", "firstName", 100, JLabel.CENTER),
new ColumnDefinition("middleName", "middleName", 100, JLabel.CENTER),
new ColumnDefinition("lastName", "lastName", 100, JLabel.CENTER),
new ColumnDefinition("streetNumber", "streetNumber", 100, JLabel.CENTER),
new ColumnDefinition("streetName", "streetName", 100, JLabel.CENTER),
new ColumnDefinition("apartmentNumber", "apartmentNumber", 100, JLabel.CENTER),
new ColumnDefinition("city", "city", 100, JLabel.CENTER),
new ColumnDefinition("state", "state", 100, JLabel.CENTER),
new ColumnDefinition("zip", "zip", 100, JLabel.CENTER)};
private static com.choicemaker.cm.core.Descriptor[] children = {
};
public boolean[] getEditable(DerivedSource src) {
return new boolean[] {
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true};
}
public String getName() {
return "person";
}
public String getRecordName() {
return "person";
}
public boolean isStackable() {
return false;
}
public ColumnDefinition[] getColumnDefinitions() {
return cols;
}
public Descriptor[] getChildren() {
return children;
}
public Record[][] getChildRecords(Record ri) {
return null;
}
public String getValueAsString(Record ri, int row, int col) {
if(row == 0) {
PersonImpl r = (PersonImpl)ri;
switch(col) {
case 0:
return r.linkage_role;
case 1:
return String.valueOf(r.entityId);
case 2:
return String.valueOf(r.recordId);
case 3:
return r.ssn;
case 4:
return r.firstName;
case 5:
return r.middleName;
case 6:
return r.lastName;
case 7:
return r.streetNumber;
case 8:
return r.streetName;
case 9:
return r.apartmentNumber;
case 10:
return r.city;
case 11:
return r.state;
case 12:
return r.zip;
default:
throw new IndexOutOfBoundsException();
}
} else {
throw new IndexOutOfBoundsException();
}
}
public Object getValue(Record ri, int row, int col) {
if(row == 0) {
PersonImpl r = (PersonImpl)ri;
switch(col) {
case 0:
return r.linkage_role;
case 1:
return String.valueOf(r.entityId);
case 2:
return String.valueOf(r.recordId);
case 3:
return r.ssn;
case 4:
return r.firstName;
case 5:
return r.middleName;
case 6:
return r.lastName;
case 7:
return r.streetNumber;
case 8:
return r.streetName;
case 9:
return r.apartmentNumber;
case 10:
return r.city;
case 11:
return r.state;
case 12:
return r.zip;
default:
throw new IndexOutOfBoundsException();
}
} else {
throw new IndexOutOfBoundsException();
}
}
public Class getHandledClass() {
return PersonImpl.class;
}
public boolean setValue(Record ri, int row, int col, String value) {
try {
if(row == 0) {
PersonImpl r = (PersonImpl)ri;
switch(col) {
case 0:
r.linkage_role = value;
break;
case 1:
r.entityId = value.length() == 0 ? (int)0 : Integer.parseInt(value);
break;
case 2:
r.recordId = value.length() == 0 ? (int)0 : Integer.parseInt(value);
break;
case 3:
r.ssn = value;
break;
case 4:
r.firstName = value;
break;
case 5:
r.middleName = value;
break;
case 6:
r.lastName = value;
break;
case 7:
r.streetNumber = value;
break;
case 8:
r.streetName = value;
break;
case 9:
r.apartmentNumber = value;
break;
case 10:
r.city = value;
break;
case 11:
r.state = value;
break;
case 12:
r.zip = value;
break;
default:
throw new IndexOutOfBoundsException();
}
return true;} else {
throw new IndexOutOfBoundsException();
}
} catch(Exception ex) {
return false;
}
}
public boolean getValidity(Record ri, int row, int col) {
if(row == 0) {
PersonImpl r = (PersonImpl)ri;
switch(col) {
case 0:
return r.__v_linkage_role;
case 1:
return r.__v_entityId;
case 2:
return r.__v_recordId;
case 3:
return r.__v_ssn;
case 4:
return r.__v_firstName;
case 5:
return r.__v_middleName;
case 6:
return r.__v_lastName;
case 7:
return r.__v_streetNumber;
case 8:
return r.__v_streetName;
case 9:
return r.__v_apartmentNumber;
case 10:
return r.__v_city;
case 11:
return r.__v_state;
case 12:
return r.__v_zip;
default:
throw new IndexOutOfBoundsException();
}
} else {
throw new IndexOutOfBoundsException();
}
}
public void addRow(int row, boolean above, Record ri) {
throw new UnsupportedOperationException("Unable to delete row. Data not stacked.");
}
public void deleteRow(Record ri, int row) {
throw new UnsupportedOperationException("Unable to add row. Data not stacked.");
}
public int getColumnCount() {
return cols.length;
}
public int getRowCount(Record ri) {
return 1;
}

public int getColumnIndexByName(String name) {
if(m == null) {
m = new HashMap(cols.length);
for(int i = 0; i < cols.length; ++i) {
m.put(cols[i].getFieldName(), new Integer(i));
}
}
Object o = m.get(name);
if(o == null) {
return -1;
} else {
return ((Integer)o).intValue();
}
}
}
