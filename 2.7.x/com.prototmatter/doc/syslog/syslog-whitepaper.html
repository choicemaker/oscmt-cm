<HTML>
<HEAD>
<TITLE>Protomatter Syslog</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">
</HEAD>
<BODY>

<TABLE WIDTH="100%" BORDER=0 CELLPADDING=0 CELLSPACING=0>
<TR><TD CLASS="whitetd" ALIGN="right">
  <TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
    <TR>
        <TH><A href="../../../../index.html">Main:</a></TH>
        <TH>White Paper</TH>
        <TH><A href="syslog-faq.html">FAQ</a></TH>
        <TH><A href="syslog-examples.html">Examples</a></TH>
        <TH><A href="package-summary.html">JavaDoc</a></TH>
        <TH><A href="classloader-warning.html">Classloader</a></TH>
        <TH><A href="syslog-performance.html">Performance</a></TH>
    </TR>
  </TABLE>
</TD></TR>
</TABLE>


<CENTER>
<H2>Protomatter Syslog</H2>
<H3>Whitepaper</H3>
<I>Nate Sammons - May, 2003</I><BR>
<I>Covers Release 1.1.8</I>
</CENTER>


<DL>

<DT><H2>Introduction</H2></DT>
<DD>

<P>
Syslog was developed to fill the need for a simple and robust logging system
that is not tied to any specific application server or to the concept of
an application server in general.  Since then, it has grown considerably
and encompases many features that are not particularly simple.  However,
it is still very simple to use and can be used in various stages
of complication.
</P>

<P>
Syslog provides the following features:
</P>

<P><UL>
<LI> Simple logging API</LI>
<LI> Background work queues (optional)</LI>
<LI> Multiple message severities</LI>
<LI> Logs the name of the thread that issued the message (optional)</LI>
<LI> Logs the name of the host that issued the message (optional)</LI>
<LI> Arbitrary log channel names</LI>
<LI> Pluggable log message listeners</LI>
<LI> Pluggable log formatting modules for each listener</LI>
<LI> Pluggable log policy modules for each listener</LI>
<LI> Startup class for WebLogic Server</LI>
<LI> Configuration can be modified on-the-fly while the system is running</LI>
<LI> A running configuration can be written to XML for re-load later</LI>
<LI> JMS integration</LI>
<LI> Remote logging capabilities</LI>
<LI> Easy-to-use Channel class for messages.</LI>
<LI> Full JDK 1.4 logging system integration, including migration tools.</LI>
<LI> Correct class name, method name and line number determined for each message (JDK 1.2.2 and higher).</LI>
<LI> Support for the UNIX syslog facility via UDP traffic.</LI>
</UL></P>

<P>
The general idea is that Syslog lets the programmer log messages easily through
a clean API and then not worry about what happens to those messages.  During
development and testing, the messages may be simply sent to the console where
the application is running or to a single log file.  When the system is moved
into production, log messages can be split up by severity (very severe messages
may result in someone being paged, for instance) and log files may be rotated
every night and archived.  These kinds of configuration changes don't require
changes to the code and can even be made while the system is running.
</P>

<P>
Syslog is licensed under the
<a href="../../../../license.html">Protomatter Software License, version 1.0</a>
and is free for commercial and non-commercial use.
</P>

</DD>
</DL>

<P>&nbsp;</P>
<H2>Syslog For Programmers</H2>

<DL>
<DT><H3>Simple Usage</H3></DT>
<DD>
<P>
Anytime a programmer wants to issue a message to Syslog, they simply call a
static method on the <TT><a href="Syslog.html">com.protomatter.syslog.Syslog</a></TT> class.  There's no
need to carry around a reference to an instance of <TT><a href="Syslog.html">Syslog</a></TT> to make calls.
This simplifies usage greatly -- there's no need for setup in a class that wants
to use Syslog:  you can just start calling log methods and that's it.
</P>

<P>
There are forty-eight methods on the <TT><a href="Syslog.html">Syslog</a></TT> class that can be used for
issuing messages to the logging system.  Having said that, it's unlikely
in the extreme that you will use all of them.  All those methods are
pass-throughs to one method which takes six arguments, so
the other forty-seven methods are all convenience methods for issuing messages.
Don't get freaked out by how many methods you have to choose from: Syslog is
a bit like a Swiss Army knife in that respect -- it probably has more blades
than you'll ever need, but they're there just in case.
</P>

<P>
The simplest way programmers usually mark up their code with messages is to
pepper the code with calls to "<TT>System.out.println()</TT>" -- and then
invariably they have to go back and comment them out before the system goes
to production.  Some calls are missed and then operations people will start to
ask why the application prints "<TT>I'm in here</TT>" continuously while it's
running.
</P>

<P>
One way to start getting accustomed to using Syslog is to replace code like
this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  System.out.println("I'm in here"); &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
With code like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  Syslog.debug(this, "I'm in here"); &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
It's not much more complicated than calling "<TT>System.out.println()</TT>"
and the output is a whole lot nicer.  Instead of getting output like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  I'm in here &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
You should see something like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  11/02/2001 10:52:53 [DBUG] Test                I'm in here &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
And if you have Syslog set to log the thread name and channel for each message,
you'll get something like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  11/01/2001 10:56:44 [DBUG] [DEFAULT_CHANNEL] [T:main  ] Test                I'm in here &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
Pretty fancy, eh?  Later, when the system goes into production, messages at the "debug"
severity can just be sent off into space and nobody will wonder why the system is
printing "<TT>I'm in here</TT>" constantly.
</P>

<P>
There are log shortcuts for handling exceptions, too.  If you call
"<TT>Syslog.log(this, x)</tt>" where <tt>x</tt> is an <tt>java.lang.Throwable</tt>, then
you'll see output like this in the log:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  11/01/2001 10:40:32 [EROR] Test                  java.lang.Exception: Crap! &nbsp;
  java.lang.Exception: Crap!
          at Test.blah(Test.java:37)
          at Test.foo(Test.java:28)
          at Test.main(Test.java:12)

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
The output of the <tt>getMessage()</tt> method is printed as the short description,
and a stack trace is printed as the detail of the message, and the whole thing
is logged at the <tt>ERROR</tt> level.  This is much better than spreading calls
to <tt>x.printStackTrace()</tt> all over your code.  As you'll see later, you can
choose to route these kinds of messages to a separate log or do any number of other
things with them.
</P>

</DD>

<DT><H3>Log Message Severity Levels</H3></DT>
<DD>

<P>
Syslog messages each have an associated "severity level" to show roughly how
important each message is.  The levels are:
</P>

<P>
<DL>

<DT><TT>DEBUG</TT></DT>
<DD>
As you might expect, these are debugging messages.  Generally referred to
as breadcrumbs -- good for letting the programmer leave little hints here and
there during the initial coding and debugging process.
</DD>

<DT><TT>INFO</TT></DT>
<DD>
Useful informational messages about what's happening.  Notable events
such as user login and logout, etc.
</DD>

<DT><TT>WARNING</TT></DT>
<DD>
Something bad has happened, but the system will attempt to recover from it.
These messages are usually used by programmers to show that something is
starting to go wrong.
</DD>

<DT><TT>ERROR</TT></DT>
<DD>
Something bad has happened, but it's not bad enough to cause the system to
fail in general.  A specific task may fail and some user may get an error,
but things will keep going.  Exceptions are generally logged at this level.
</DD>

<DT><TT>FATAL</TT></DT>
<DD>
Something really, really bad has happened.  The system is probably now in
a state where it's not going to be very useful to anyone.  Someone should
probably be paged.
</DD>

</DL>
</P>

<P>
It's really important to actually use the different severity levels where
they are appropriate.  If every message in the system is logged at
the "debug" level, the operations team can't tune things out without tuning
everything out.
</P>

</DD>


<DT><H3>Log Methods</H3></DT>
<DD>

<P>
Before we go much further, let's look at the logging methods that
are available on the <TT><a href="Syslog.html">Syslog</a></TT> class.  The fall into three
categories:
</P>

<P>
<DL>

<DT><TT>log(...)</TT></DT>
<DD>
They have the following forms:

<P>
<PRE>
log(Object logger, Throwable t)
log(Object logger, Throwable t, int level)
log(Object logger, Object msg, Object detail, int level)
log(Object logger, Object chan, Object msg, Object detail, int level)
log(InetAddress host, Object logger, Throwable t)
log(InetAddress host, Object logger, Throwable t, int level)
log(InetAddress host, Object logger, Object msg, Object detail, int level)
log(InetAddress host, Object logger, Object chan, Object msg, Object detail, int level)
</PRE>
</P>
</DD>


<DT><TT>xxx(...)</TT></DT>
<DD>
Where "<TT>xxx</TT>" is "<TT>debug</TT>", "<TT>info</TT>",
"<TT>warning</TT>", "<TT>error</TT>", or "<TT>fatal</TT>"
These are shortcuts to the <TT>log(...)</TT> method for each
log level.  They have the following forms:

<P>
<PRE>
xxx(Object logger, Object msg)
xxx(Object logger, Object msg, Object detail)
xxx(InetAddress host, Object logger, Object msg)
xxx(InetAddress host, Object logger, Object msg, Object detail)
</PRE>
</P>
</DD>


<DT><TT>xxxToChannel(...)</TT></DT>
<DD>
Where "<TT>xxx</TT>" is "<TT>debug</TT>", "<TT>info</TT>",
"<TT>warning</TT>", "<TT>error</TT>", or "<TT>fatal</TT>"
These are shortcuts to the <TT>log(...)</TT> method for each
log level, and to a specific channel. They have the following forms:

<P><PRE>
xxxToChannel(Object logger, Object chan, Object msg)
xxxToChannel(Object logger, Object chan, Object msg, Object detail)
xxxToChannel(InetAddress host, Object logger, Object chan, Object msg)
xxxToChannel(InetAddress host, Object logger, Object chan, Object msg, Object detail)
</PRE>
</P>
</DD>

</DL>
</P>

<P>
It's fairly safe to assume that you'll never use any of the methods
that include the <TT>InetAddress</TT> argument.  These are used internally
by Syslog, and an generally of no concern to the programmer.
The rest of the arguments to the methods are:
</P>

<P>
<DL>

<P>
<DT><TT>Object logger</TT></DT>
<DD>
This is the object making the log request.  Generally, the logger
argument is simple "<TT>this</TT>" -- like in the example above.
If there's no "<TT>this</TT>" reference where you want to do some
logging (in a <TT>static</TT> method, for instance), simply pass
the current class object in (if you're in a static method in
the "<TT>MyClass</TT>" class, simply pass in "<TT>MyClass.class</TT>"
instead of "<TT>this</TT>").
</DD>
</P>

<P>
<DT><TT>Throwable t</TT></DT>
<DD>
The methods above that explicitly take a <TT>Throwable</TT> as
an argument are convenience methods.  The <TT>toString()</TT> method
on the <TT>Throwable</TT> is called, and it's result is passed in
as the <TT>msg</TT> argument.  In the case of the method that
takes a <TT>Throwable</TT> and doe not take a <TT>level</TT> argument,
the level is set to "error".  The <TT>Throwable</TT> itself is passed
on as the <TT>detail</TT> argument.
</DD>
</P>

<P>
<DT><TT>Object msg</TT></DT>
<DD>
This is intended to be a short (one-liner) description of the message.  The
<TT>toString()</TT> method of whatever is passed in will be called.
</DD>
</P>

<P>
<DT><TT>Object detail</TT></DT>
<DD>
If included (this argument can be <TT>null</TT>), this is treated as
a longer explanation of the message.  If the object passed as this
argument extends <TT>Throwable</TT> then a stack trace is generated
and used here.
</DD>
</P>

<P>
<DT><TT>int level</TT></DT>
<DD>
This is the severity level of the message.  There are constants defined on
the <TT>Syslog</TT> class for these:  <TT>Syslog.DEBUG</TT>, <TT>Syslog.INFO</TT>,
<TT>Syslog.WARNING</TT>, <TT>Syslog.ERROR</TT> and <TT>Syslog.FATAL</TT>.
</DD>
</P>

<P>
<DT><TT>Object channel</TT></DT>
<DD>
This is the channel name for this message.  This can be one of two things:
A <TT>String</TT> or an array of <TT>String</TT>s (in which case the
message is dispatched to every channel specified in the array).  The default value
is <TT>Syslog.ALL_CHANNEL</TT>.
</DD>
</P>

</DL>
</P>

<P>
<B>Note:</B> Exact formatting of the arguments above is actually dependent
on what log formatting module is used by the logger handling the request.
The above explanations of formatting assume that you are using the default
log formatting module and not one of your own design.
</P>

<P>
<I><B>Don't Freak Out:</B></I> Yes, there's a bunch of methods
there.  You'll probably never, ever use all of them.  If you
really must have a smaller API, take a look at the
<TT><A href="Channel.html">Channel</A></TT> object.  It provides
a simplified logging API.
</P>


</DD>


<DT><H3>Log Message Channels</H3></DT>
<DD>

<P>
A more advanced feature of Syslog is it's support for multiple log channels,
defined on-the-fly.  The basic idea is that one instance of an application
server (such as BEA WebLogic Server) may host multiple projects who each
want to have their logs dealt with separately.  From the programmer's perspective,
message are just sent into channels and someone else deals with them.
What happens to these messages (what files they end up in, etc) is something
that can be configured at runtime.  There is a default channel (whose name is
the constant <TT>Syslog.DEFAULT_CHANNEL</TT> on the <TT><a href="Syslog.html">Syslog</a></TT> class)
that messages go to by default, and there is also a channel named
<TT>Syslog.ALL_CHANNEL</TT> that can be used to broadcast messages to every channel.
</P>

<P>
Let's say that you're running two projects ("BigBank" and "SomeOtherBigBank")
on the same instance of WebLogic Server.  You might want all log messages from the
BigBank project to go to the "<TT>BigBankChannel</TT>" channel, and all log messages
from the SomeOtherBigBank project to go to the "<TT>SomeOtherBigBankChannel</TT>"
channel.  There are two ways to accomplish this:
</P>

<P>
The first way is to call versions of the <TT>log(...)</TT> methods above
that take a <TT>channel</TT> argument and specify the channel everywhere.
This will quickly become very annoying and you'll end up either misspelling
the channel name somewhere.  One way to mitigate this is to have some interface
in your project that defines a <TT>public static</TT> constant like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  public interface BigBank
  {
    public static Object SyslogChannel = "BigBankChannel"; &nbsp;
  }

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
Then have every class specific to the BigBank project implement that
interface or use it when calling <TT>log(...)</TT> methods, like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  // if the current class implements the "BigBank" interface
  Syslog.debugToChannel(this, SyslogChannel, "Hello there");
  ...
  // if the current class doesn't implement the "BigBank" interface
  Syslog.debugToChannel(this, BigBank.SyslogChannel, "Hello there"); &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
Programmers will quickly tire of this, though, and invariably there will be
messages leaking out going to other channels, etc.
</P>


<P>
Because the above method of sending message to channels is annoying,
the <TT><a href="SyslogChannelAware.html">SyslogChannelAware</a></TT> interface
was written.  It looks like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  public interface SyslogChannelAware &nbsp;
  {
    public Object getSyslogChannel(); &nbsp;
  }

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
Not too complicated.  The idea is that any object passed in as the <TT>logger</TT>
argument to one of the <TT>log(...)</TT> methods (usually "<TT>this</TT>") that
implements this interface is asked what channels it wants the message to go to.
If the call to Syslog included a channel (i.e. was one of the
"<TT>xxxToChannel(...)</TT>" methods, etc.) then the class is not asked what channels
it wants the message to go to.
</P>

<P>
Why is this good?  Most of the classes in modern classes are built on top of
more generic classes -- baseclasses from frameworks, etc.  If each of the
baseclasses used in your system implements this interface, the programmers
writing subclasses never have to bother with channel names, etc.  The baseclass
can read a list of channels to use out of a configuration file or from some
other source.  This works particularly well in the case of EJBs since you could
specify channels to use in the deployment descriptor for the bean.  This
kind of flexibility means that when a system is moved into production,
different subsystems can be configured to write messages to different log
channels without needing to change any code.  Programmers just keep making calls
to "<TT>Syslog.debug(...)</TT>" and other methods, and the messages are magically
routed to the correct channel dynamically.
</P>

</DD>

<DT><H3>Simplified Channel Logging API</H3></DT>
<DD>

<P>
The <TT><A href="Channel.html">Channel</A></TT> class provides
a greatly-simplified API for making log calls.  Use it like
this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  // some short messages
  Channel default = Channel.getDefaultChannel();
  default.debug(this, "Hello there... this is a debug message");
  default.error(this, "Hello there... this is an error message"); &nbsp;

  // some long messages (messages with detail)
  Channel systemChannel = Channel.getChannel("system");
  systemChannel.info(this, "Hello there...", someLongString);
  systemChannel.error(this, "Hello there...", someLongString);

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
One criticism of Syslog over other logging APIs, particularly
Log4J, is that Log4J includes its named logger API.  This
channel API for Syslog is analogous to this feature in
Log4J.  It's not the same, but it's similar.
I find this new channel API very easy to use (compared with
the "regular" Syslog API).  It's small and clean.
</P>

</DD>

<DT><H3>Code Examples</H3></DT>
<DD>

<P>
Here's a simple example of how to write messages at different
severities:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  // some short messages -- to the default channel
  Syslog.debug(this, "Hello there... this is a debug message");
  Syslog.info(this, "Hello there... this is an info message");
  Syslog.warning(this, "Hello there... this is a warning message");
  Syslog.error(this, "Hello there... this is an error message");
  Syslog.fatal(this, "Hello there... this is a fatal message");

  // some long messages (messages with detail) -- to the default channel &nbsp;
  Syslog.debug(this, "Hello there...", someLongString);
  Syslog.info(this, "Hello there...", someLongString);
  Syslog.warning(this, "Hello there...", someLongString);
  Syslog.error(this, "Hello there...", someLongString);
  Syslog.fatal(this, "Hello there...", someLongString);

  // misc log messages to some named channels
  Channel system = Channel.getChannel("system");
  system.info(this, "This is an info message to the system channel");
  system.debug(this, "This is a debug message");

  Channel security = Channel.getChannel("security");
  security.warning(this, "Failed login attempt");

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
Here's an example of how to handle exceptions.  This code will produce a
stack trace in the log if a <TT>SQLException</TT> is encountered.
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  try
  {
    // do some stuff with a database here
  }
  catch (SQLException x)
  {
    Syslog.log(this, x);
    // or
    someChannel.log(this, x);

    throw new MyCustomException("Could not do some stuff!"); &nbsp;
  }

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
These examples should be good enough to get you through 95% of what you'll need
to do with Syslog.  If you're curious, play around with all the other methods
that can be used to write log messages.
</P>

</DD>

<DT><H3>JDK 1.4 Logging API Integration</H3></DT>
<DD>

<P>
<I>Standard Is Better Than Good</I>.  Like it or not, a standard logging
API is available as part of the JDK, starting with JDK 1.4.  This new
package, <TT>java.util.logging</TT> provides a common logging API.
</P>

<P>
Syslog is <I>fully</I> compatible with this new logging API.  With
a very simple properties file and a couple of command-line arguments
to the JVM, you can transparently route all JDK-based logging calls
straight into Syslog where they will be handled appropriately.
</P>

<P>
Given the following file (call it "<TT>logging.properties</TT>"
for this example):
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  .level = ALL

  handlers = com.protomatter.syslog.SyslogHandler &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
That file will instruct the JDK's logging framework to
route all messages to the Syslog handler (an adapter
from the JDK 1.4 logging framework to Syslog).
</P>

<P>
Next, run your program, including a couple of special
options:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  java \
    ...
    -Djava.util.logging.config.file=/path/to/logging.properties    \ &nbsp;
    -DSyslogHandler.xml=/path/to/syslog.xml                        \ 
    ...
    java-main-class

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
These extra options tell the JDK 1.4 logging framework where to
read the config file from, and it also tells the Syslog adapter
where a config file is.  If you're using multiple configuration
files, or doing something fancy, you can omit the
<TT>SyslogHandler.xml</TT> option and configure Syslog
yourself (JDK logging calls will still be routed to Syslog).
</P>

<P>
Given code like the following (note that there are no
Syslog calls, and no references to Syslog):
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  import java.util.logging.Logger

  ...

  // Make a new logger
  Logger myLogger = Logger.getLogger("foo.bar");

  // Write some log messages
  myLogger.info("Info message to my logger");
  myLogger.warning("Warning message to my logger"); &nbsp;
  myLogger.severe("Severe message to my logger");

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
You should see the following output:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  11/01/2001 20:09:16 [INFO] [foo.bar        ] Test.main():23      Info message to my logger
  11/01/2001 20:09:16 [WARN] [foo.bar        ] Test.main():25      Warning message to my logger &nbsp;
  11/01/2001 20:09:16 [EROR] [foo.bar        ] Test.main():27      Severe message to my logger

</PRE>
</TD></TR></TABLE>
</UL></P>


<P>
Note the method name and line numbers in the output.  Through a new
API in JDK 1.4, Syslog is able to determine the class name, method
name and source file line number where the original call to either
the JDK 1.4 logging API or a Syslog API.  See the next section
for more details.
</P>

<P>
Also see the
<tt><a href="util/logging/package-summary.html">com.protomatter.syslog.util.logging</a></tt>
package documentation for migration tools for JDK 1.2.x and 1.3.x.
</P>

</DD><P>

<DT><H3>Computing caller class, method and line numbers</H3></DT>
<DD>

<P>
Syslog can be configured to compute the correct caller
class name, method name and line number at runtime.
Under JDK 1.2 and 1.3, this is done by parsing a
stack trace, and in JDK 1.4 is it accomplished by
using new API calls on exceptions.
See <tt><a href="../util/StackTraceUtil.html">com.protomatter.util.StackTraceUtil</a></tt>
for more information.
</P>

<P>
Syslog has two settings that govern if and when this
infomation is computed.  This feature is extremely
useful for debugging, but can also degrade performance.
</P>

<P>
The <tt><a href="Syslog.html#setComputeCaller(boolean)">Syslog.setComputeCaller()</a></TT>
method tells Syslog if it should compute the caller information
before calling the <tt>log()</tt> method on a logger.  If this
is set to <tt>true</tt>, then the logger will have access to
the correct caller information, but the log policy won't have
the method or line number available.  The default value for
this setting is <tt>false</tt>.
</P>

<P>
The <tt><a href="Syslog.html#setAlwaysComputeCaller(boolean)">Syslog.setAlwaysComputeCaller()</a></TT>
method tells Syslog if it should compute the caller information
for every log method call.  If this is set to <tt>true</tt>, then
both the logger and the policy will have access to
the correct caller information, but the log policy won't have
the method or line number available.  The default value for
this setting is <tt>false</tt>.  The reason for this is that
unless the log policy is selecting based on method name or
caller class name, it is expensive to compute the caller for
every log call (since many calls do not pass the policy test).
</P>

</DD><P>

<DT><H3>Apache Jakarta Commons Logging API Integration</H3></DT>
<DD>

<P>
The
<a href="http://jakarta.apache.org/commons/logging.html">Apache Jakarta Commons Logging API</a>
is a super-thin logging API with pluggable backends
including Log4J and other APIs.
The <tt><a href="commons/package-summary.html">com.protomatter.syslog.commons</a></tt>
package includes adapter classes for that API.
</P>

<P>
Given a simple configuration file, this API
allows you to write code like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;

 ...

 Log log = LogFactory.getLog("foo.bar");

 log.info("This is an info message");
 log.error("This is an error message");
 log.error("This is an error message", new Exception("Blah!")); &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
The logging calls will be routed to Syslog and handled
accordingly.
</P>

</DD><P>

<DT><H3>Debugging aides for performance in production</H3></DT>
<DD>

<P>
The <tt><a href="../util/Debug.html">Debug</a></tt> class
provides a useful tool for keeping very expensive
operations out of production systems without the need
to recompile to make the change.  It provides a hierarchical
naming scheme and allows wildcards to turn things on and off.
</P>

<P>
You can use the
<tt><a href="../util/Debug.html#addTraceName(java.lang.String)">Debug.addTraceName()</a></tt>,
<tt><a href="../util/Debug.html#addDebugName(java.lang.String)">Debug.addDebugName()</a></tt> and
<tt><a href="../util/Debug.html#addInfoName(java.lang.String)">Debug.addInfoName()</a></tt>
methods to add name patterns and/or explicit names to the list
of things to match against.
</P>

<P>
For instance, if you add the following patterns:
</P>

<P>
<dl>
  <dd><tt>com.protomatter</tt></dd>
  <dd><tt>com.protomatter.syslog.*</tt></dd>
  <dd><tt>com.protomatter.util.*</tt></dd>
  <dd><tt>com.protomatter.foo.bar.*</tt></dd>
</dl></P>

<P>Then the following names would "match" the
patterns:</P>

<P>
<dl>
  <dd><tt>com.protomatter</tt></dd>
  <dd><tt>com.protomatter.syslog</tt></dd>
  <dd><tt>com.protomatter.syslog.xml</tt></dd>
  <dd><tt>com.protomatter.util.other.package</tt></dd>
</dl></P>

<P>And the following names would not "match" the
patterns:</P>

<P>
<dl>
  <dd><tt>com.protomatterfoo</tt></dd>
  <dd><tt>com.protomatter</tt></dd>
  <dd><tt>com.protomatter.foo</tt></dd>
  <dd><tt>com.protomatter.jdbc.pool</tt></dd>
</dl></P>

<P>
This class is useful in a debugging aid,
like this:</P>

<P>
<UL><TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
<TR><TD>
<PRE><B>
  
  import com.protomatter.util.Debug;
  import com.protomatter.util.StackTraceUtil;
  
  import com.protomatter.syslog.Channel;

  ...
  
  protected static Debug debug = Debug.forPackage(ThisClass.class); &nbsp;

  protected static Channel channel = Channel.forPackage(ThisClass.class); &nbsp;

  ...

  // three levels:  trace, debug and info
  if (debug.trace())
      channel.debug(this, "Very detailed tracing information");


  // debugging messages
  if (debug.debug())
      channel.debug(this, "I'm over here -> " + StackTraceUtil.whereAmI()); &nbsp;


  // infomration messages
  if (debug.info())
      channel.info(this, "Non-programmer kinds of messages");

</B></PRE>
</TD></TR></TABLE></UL></P>

<P>
This can prevent expensive operations involved in debugging
to be quickly bypassed in production environments
by changing a configuration file instead of re-compiling.</P>

<P>
You can configure a pattern/name list using the XML configuration
file for Syslog.  See the JavaDoc for
<tt><a href="xml/SyslogXML.html#configure(org.jdom.Element)">SyslogXML.configure()</a></tt>
for more information.
</P>

</DD>

</DL>

<P>&nbsp;</P>
<H2>Syslog Internals</H2>
<DL>

<DT><H3>Architecture</H3></DT>
<DD>

<P>
The <TT><a href="Syslog.html">Syslog</a></TT> class itself is a
singleton -- that is, there is only one
instance of it per VM (or at least per classloader if you want to get picky).
It contains all configuration information related to where messages are
routed, who is listening for those messages, etc.
</P>

<P>
<CENTER>
<TABLE BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR>
<TD><IMG SRC="syslog-architecture.png"></TD>
</TR>
<TR>
<TD ALIGN=CENTER>
<B>Abbreviated Syslog Architecture Diagram</B>
</TD>
</TR>

</TABLE>
</CENTER>
</P>

<P>
Syslog maintains a list of loggers -- objects that want to listen to log
messages being submitted.  These loggers implement the
<TT><a href="Syslogger.html">Syslogger</a></TT>
interface -- mainly the <TT>log(SyslogMessage message)</TT> method
which is called every time a message is sent to Syslog.
</P>

<P>
Once the <TT>log()</TT> method is called on the
<TT><a href="Syslogger.html">Syslogger</a></TT> it
should (very quickly) decide if the message being logged is
one that it cares about.  If the message is relevant, then the
logger writes the message to a file or does whatever it wants with it.
</P>

</DD>


<DT><H3>Default Implementations</H3></DT>
<DD>

<P>
The default implementation of the <TT><a href="Syslogger.html">Syslogger</a></TT> interface is the
<TT><a href="BasicLogger.html">BasicLogger</a></TT> abstract class.  This is the baseclass for all the
loggers that are included with Syslog.
</P>

<P>
The <TT><a href="BasicLogger.html">BasicLogger</a></TT> delegates the decision about paying attention
to a given message to an implementation of the <TT><a href="LogPolicy.html">LogPolicy</a></TT> interface.
The default implementation of the <TT><a href="LogPolicy.html">LogPolicy</a></TT> interface is the
<TT><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT> class.  This policy knows about log message
severity levels and about log channels -- it can be configured to only
pay attention to messages at a certain level (or set of levels) and to
only pay attention to messages arriving on a certain channel (or set
of channels).  This policy could easily be extended to take into
account any other inputs desired (you could, for instance, have a policy
that only paid attention to messages coming from objects of a certain
class, etc).
</P>

<P>
The <TT><a href="BasicLogger.html">BasicLogger</a></TT> also delegates it's message formatting duties
to an implementation of the <TT><a href="SyslogTextFormatter.html">SyslogTextFormatter</a></TT> interface.
The default implementation of this interface is the
<TT><a href="SimpleSyslogTextFormatter.html">SimpleSyslogTextFormatter</a></TT> class which can be configured to
format log messages in a number of ways.
</P>

<P>
During initialization (in the <TT>configure(...)</TT> method) the <TT><a href="BasicLogger.html">BasicLogger</a></TT>
passes it's initialization properties along to the <TT>configure(...)</TT> method
on the log policy module and text formatting module that have been specified.
Because of this, any policy or formatter module can be configured easily
(this becomes particularly important when working inside an application
server such as BEA WebLogic Server).
</P>

<P>
If, for some reason, you want to plug in your own <TT><a href="LogPolicy.html">LogPolicy</a></TT>
implementation or your own <TT><a href="SyslogTextFormatter.html">SyslogTextFormatter</a></TT> implementation
it's very simple to do with any logger that extends from <TT><a href="BasicLogger.html">BasicLogger</a></TT>.
</P>


</DD>


<DT><H3></H3></DT>
<DD>
</DD>

</DL>


<P>&nbsp;</P>
<H2>Syslog For Operations</H2>
<DL>

<DT><H3>Included Loggers</H3></DT>
<DD>

<P>
There are several loggers included with the Syslog distribution that
cover most of the bases as far as log functionality is concerned.  They are:
</P>

<P>
<DL>

<P>
<DT><TT><a href="PrintWriterLog.html">PrintWriterLog</a></TT></DT>
<DD>
A logger that is attached to an instance of <TT>java.io.PrintWriter</TT>.
This logger is generally attached to either <TT>System.out</TT> or
<TT>System.err</TT> at runtime.
</DD>
</P>

<P>
<DT><TT><a href="TimeRolloverLog.html">TimeRolloverLog</a></TT></DT>
<DD>
A logger that writes to a file that is rotated every minute, hour, day or month.
</DD>
</P>

<P>
<DT><TT><a href="LengthRolloverLog.html">LengthRolloverLog</a></TT></DT>
<DD>
A logger that writes to a file that is rotated before it reaches a certain length.
</DD>
</P>

<P>
<DT><TT><a href="FileLog.html">FileLog</a></TT></DT>
<DD>
A logger that simply writes to a file.
</DD>
</P>

<P>
<DT><TT><a href="OpenFileLog.html">OpenFileLog</a></TT></DT>
<DD>
A logger that writes to a file.  The file is opened before and closed
after each message is written.  This is a very slow logger and should not
be used unless there's some odd reason that justifies its use.
</DD>
</P>

<P>
<DT><TT><a href="DatabaseLog.html">DatabaseLog</a></TT></DT>
<DD>
A logger that writes messages to a table in a database.  This is
very useful when you have multiple machines involved in a project
and you want to have a unified view of everything happening on
all the machines.
</DD>
</P>

<P>
<DT><TT><a href="MailLog.html">MailLog</a></TT></DT>
<DD>
A logger that connects directly to an SMTP server to
send out email.  It can either send plain text messages,
or messages formatter in HTML.
</DD>
</P>

<P>
<DT><TT><a href="UNIXSyslogLog.html">UNIXSyslogLog</a></TT></DT>
<DD>
A logger that sends UDP packets to a UNIX syslog server.
This can be used as part of a monitoring and notification
system.  For instance -- you can do the equivalent of
a "wall" on a UNIX machine when you call <TT>Syslog.fatal()</TT>
by using this logger.
</DD>
</P>

<P>
<DT><TT><a href="JMSLog.html">JMSLog</a></TT></DT>
<DD>
A logger that publishes messages onto a JMS topic, and obeys
any JTS transaction context present.  This logger is designed
as the mechanism to send messages to a remote log server.
</DD>
</P>

<P>
<DT><TT><a href="RemoteLog.html">RemoteLog</a></TT></DT>
<DD>
A logger that sends messages to objects bound under the
"<tt>com.protomatter.syslog.remote</TT>" location in
JNDI that implement the <tt><a href="RemoteLogReceiver.html">RemoteLogReceiver</a></tt> interface.
This can be used as a non-transactional transport for messages
to remote log servers.
</DD>
</P>

</DL>
</P>

<P>
Each of the above loggers extends <TT><a href="BasicLogger.html">BasicLogger</a></TT> and so supports
pluggable log policies.  All of them except for the <TT><a href="DatabaseLog.html">DatabaseLog</a></TT>
support pluggable text formatting modules.
</P>

</DD>


<DT><H3>Syslog and BEA WebLogic Server</H3></DT>
<DD>

<P>
A startup class for BEA WebLogic Server is provided with the Syslog
distribution.  It allows Syslog to be initialized when WebLogic
boots.
</P>

<P>
To configure weblogic to initialize Syslog when it starts, add
the following line to your <TT>weblogic.properties</TT> file:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  weblogic.system.startupClass.Syslog=com.protomatter.syslog.SyslogT3Startup &nbsp;
  java.system.property.Syslog.config.xml=<i>ConfigFilePath</i>

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
You can either set the "<TT>Syslog.config.xml</tt>" system property by
specifying it in the <tt>weblogic.properties</tt> file (as shown above),
or by adding "<TT>-DSyslog.config.xml=<i>ConfigFilePath</i></tt>" as
a command-line argument to the Java VM in the startup script for WebLogic.
</P>

<P>
The <TT><a href="SyslogT3Startup.html">SyslogT3Startup</a></TT> class
implements the <TT>weblogic.common.T3StartupDef</TT>
interface required for startup classes in WebLogic Server.  That class also implements the
<TT>weblogic.common.T3ShutdownDef</TT> interface, and will wait for all
loggers to finish writing log entries and gracefully close all
logs when WebLogic shuts down.  To configure this behavior, add the following
line to your <tt>weblogic.properties</tt> file:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  weblogic.system.shutdownClass.Syslog=com.protomatter.syslog.SyslogT3Startup &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
If, for some reason,
you have a startup class of your own that needs to ensure that Syslog has
been configured before it starts, you can include the following code in the
<TT>startup(...)</TT> method of your <TT>T3StartupDef</TT> implementation:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  SyslogT3Startup syslogStartup = new SyslogT3Startup(); &nbsp;
  syslogStartup.startup(services);

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
In addition to this method of configuration, you can also use the
less server-specific Servlet- and J2EE-related configuration
options discussed below.
</P>

<DT><H3>Syslog and <A href="http://www.jboss.org">JBoss</A></H3></DT>
<DD>

<P>
Using the classes in the <tt><a href="jmx/package-summary.html">jmx</a></TT>
package, you can configure JBoss to load and configure Syslog when
it boots.
</P>

<P>
Simply add the following lines to your <TT>jboss.mlet</TT> file:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

 &lt;mbean code="com.protomatter.syslog.jmx.Syslog"
          name="DefaultDomain:service=Log,type=Syslog"&gt; &nbsp;
 &lt;/mbean&gt;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
When JBoss boots, it will load Syslog.  Syslog will then look
for a configuration file called "<TT>syslog.xml</TT>" which should
be in the same directory as your "<TT>jboss.mlet</TT>" configuration
file.  You should also see Syslog appear in the JBoss management
console.
</P>

<P>
You will need to place the protomatter jar file and the JDom jar
file in your "<TT>lib/ext</TT>" directory for that JBoss instance.
This will allow JBoss to find the necessary classes when loading
Syslog.
</P>

</DD>

<DT><H3>Syslog and Servlet Engines (including most J2EE App Servers)</H3></DT>
<DD>

<P>
Using the <tt><a href="xml/SyslogInitServlet.html">SyslogInitServlet</a></TT>
servlet in a Servlet 2.2 or higher Servlet container, you can initialize
Syslog automatically when a WebApp goes "live".  Simply configure
your <TT>web.xml</TT> for the App and configure that servlet (see
the <a href="xml/SyslogInitServlet.html">JavaDoc</a> for more info).
</P>

<P>
The 2.2 Servlet specification allows for the loading and initialization
of Servlets when a WebApp loads.  In some cases, this is the only
way to automatically load Syslog without writing custome code.  To
configure your WebApp to load and configure Syslog when that app
is booted, add the following to your <TT>web.xml</TT> file:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  &lt;servlet&gt;
    &lt;servlet-name&gt;SyslogInitServlet&lt;/servlet-name&gt;
    &lt;description&gt;Syslog Initialization Servlet&lt;/description&gt;
    &lt;servlet-class&gt;com.protomatter.syslog.xml.SyslogInitServlet&lt;/servlet-class&gt; &nbsp;
    &lt;init-param&gt;
      &lt;param-name&gt;config.xml&lt;/param-name&gt;
      &lt;param-value&gt;/path/to/syslog.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;show.config.on.get&lt;/param-name&gt;
      &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SyslogInitServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/SyslogInitServlet&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
The <TT>config.xml</TT> init param is requred and should point
to the XML configuration file for Syslog.
</P>

<P>
If the optional <TT>show.config.on.get</TT> init param is set
to <TT>true</TT> (the default is <TT>false</TT>), then when
the servlet is hit with a <TT>GET</TT> request, it will return the
current Syslog configuration.  Care should be taken when using this
option since the syslog configuration file may contain database
passwords, etc.  It is a good idea to use declarative security
to protect this servlet if you are allowing it to display the
configuration file.
</P>

<P>
The <TT>&lt;servlet-mapping&gt;</TT> tag above is optional.  If
it is not specified, the servlet will still initialize syslog when
the WebApp comes up, but the servlet will not be visible to
web browsers.  This is generally a good thing.
</P>

<P>
Also, please note that the Protomatter jar file should be placed
in your <I>system CLASSPATH</I> and not just included in the
lib directory for your WebApp.  This will ensure that Syslog
is available inside all software running in your application server.
For more discussion on this topic, please read the
<A href="classloader-warning.html">classloader issues document</A>.
</P>

</DD>

<DT><H3>Syslog and J2EE Application Servers</H3></DT>
<DD>

<P>
My personal approach is that each server in a cluster should just
write log files to local filesystems and that's it (except for
use of the <TT><A href="MailLog.html">MailLog</A></TT> and possibly
the <TT><A href="DatabaseLog.html">DatabaseLog</A></TT> loggers).
This is the simplest and most bomb-proof way of doing logging,
and therefore the one I would most recomend for production environments.
It does not rely on networks being up, cluster services
(or even the cluster itself) like RMI and other (more complicated and
therefore more failure-prone) network-related services like
distributed JNDI, JMS, etc.  It delivers 99% of the flexability
wanted and none of the added failure possibilities of that other
1% of the features.
</P>

<P>
Please read the documentation related to
<A href="classloader-warning.html">classloaders and Syslog</A>
because it has a great deal of relavancy in J2EE applications.
It explains how it is possible for each EAR in a J2EE server
to have its own Syslog configuration.
</P>

<P>&nbsp;</P>

<P>
Using the <tt><a href="JMSLog.html">JMSLog</a></TT> or
<tt><a href="RemoteLog.html">RemoteLog</a></tt> loggers and the
<tt><a href="SyslogServer.html">com.protomatter.syslog.SyslogServer</a></tt> command-line application,
it is possible to route messages to a remote log server for
processing. If the <tt><a href="JMSLog.html">JMSLog</a></tt> logger is used, the logging of
those messages obey J2EE transactions inside the application server.
</P>

<P>
This is a complicated matter.  With that complexity, however, comes a great deal
of flexability.  Consider this:  A cluster of application servers wants to
relay transactionally correct usage information to a remote log server, which
will separate messages into different log files and roll them over every hour.
However, each machine in the cluster wants to log all errors and send email out
to administrators when certain (very bad) conditions occur.  Syslog can do
this... here's how:
</P>

<DL>
<DT><B>Application Server(s)</B></DT>
<DD>
Syslog is configured to start when the application server boots.  Its
configuration includes the following loggers:<P>

<DL>

<DT><I><a href="TimeRolloverLog.html">TimeRolloverLog</a></I></DT>
<DD>
Configured to write all messages at or above the <TT>WARNING</TT>
level out to a file on the local filesystem.
</DD><P>

<DT><I><a href="PrintWriterLog.html">PrintWriterLog</a></I></DT>
<DD>
Configured to write all messages at or above the <TT>WARNING</TT>
level out to the console (<tt>System.out</tt>).
</DD><P>

<DT><I><a href="JMSLog.html">JMSLog</a></I></DT>
<DD>
Configured to forward all messages at or above the <TT>INFO</TT>
level to a JMS topic for further processing on another machine.
</DD><P>

<DT><I><a href="MailLog.html">MailLog</a></I></DT>
<DD>
Configured to send email to an email alias for the on-call
operations staff pager when a message at or above the <TT>ERROR</TT>
level is logged.
</DD><P>

</DL>


</DD>


<DT><B>Log Server</B></DT>
<DD>
Runs the <tt><a href="SyslogServer.html">com.protomatter.syslog.SyslogServer</a></tt> standalone
log server, and connects to the JMS topic hosted by the application
server cluster.  Syslog's configuration includes the following loggers:<P>

<DL>

<DT><I><a href="TimeRolloverLog.html">TimeRolloverLog</a></I></DT>
<DD>
Several instances of this logger, each listening to a different
log channel (one for each hosted application) and configured to
write all messages at or above the <TT>WARNING</TT> level out to
a file on the local filesystem.
</DD><P>

<DT><I><a href="TimeRolloverLog.html">TimeRolloverLog</a></I></DT>
<DD>
Several instances of this logger, each listening to a different
log channel (one for each hosted application) and configured to
write all messages at the <TT>INFO</TT> level out to site usage
logs on the local filesystem.
</DD><P>

<DT><I><a href="PrintWriterLog.html">PrintWriterLog</a></I></DT>
<DD>
Configured to write all messages at or above the <TT>WARNING</TT>
level out to the console (<tt>System.out</tt>).
</DD><P>

</DL>
</DD>

<P>
Also note that Syslog uses a JMS topic (rather than a queue).  Because
of this, multiple log servers could be configured to handle different
sets of messages (or to redundantly handle the same messages).
Splitting up the messages can either be done by specifying log
policies on each server that select the messages or by using a JMS
message selector to selectively process messages.
</P>

<P>
Keep in mind that all this configuration can be done without changing
a single line of source code in the system (and thus changes can be
made without the need to recompile anything).  It could even be modified
after the system has been running.  If a given component is having
problems, start logging <i>all</i> messages coming from that component
to a separate log file (using the <tt><a href="FileLog.html">FileLog</a></tt> logger and the
<tt><a href="PerClassPolicy.html">PerClassPolicy</a></tt> or
<tt><a href="PerChannelPolicy.html">PerChannelPolicy</a></tt>
log policy to select messages).
</P>

<P>
If the messages do not need to obey J2EE transaction contexts in the
application server (or they <i>must</i> not obey them), then
simply replace the <tt><a href="JMSLog.html">JMSLog</a></tt>
with the <tt><a href="RemoteLog.html">RemoteLog</a></tt> in
the application server, and modify the configuration of the
log server accordingly.  Messages will be sent via RMI instead of
being carried across a JMS topic.  Again, multiple servers can
be used to receive those messages.
</P>

</DL>

</DD>






<DT><H3>Syslog and other systems</H3></DT>
<DD>

<P>
If Syslog needs to be configured from inside another server or application,
the <TT>Syslog.configure()</TT> method can be used.  It will configure
syslog from an XML file.
</P>

<P>
Syslog can also be configured programatically.  Loggers can be added,
removed and configured while things are running using methods on
the <TT><a href="Syslog.html">Syslog</a></TT> class.
</P>

<P>
Syslog can also be used to log messages coming from other systems that
take a <tt>PrintWriter</tt> or <tt>Writer</tt> to write log messages to.
Using the <tt><a href="SyslogWriter.html">SyslogWriter</a></tt> it is
possible to create a <tt>PrintWriter</tt> that, when written to, issues
messages to Syslog on a given channel at a given severity level.
</P>

</DD>






<DT><H3>Configuring Loggers</H3></DT>
<DD>

<P>
Examples of XML configuration files can
be found <A href="syslog-examples.html">over here</A>.
A basic Syslog configuration file looks like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  &lt;Syslog defaultMask="DEBUG"&gt;

    &lt;Logger name="myPrintWriterLog"
      class="com.protomatter.syslog.PrintWriterLog"&gt;

      &lt;stream&gt;System.out&lt;/stream&gt;

      &lt;Policy class="com.protomatter.syslog.SimpleLogPolicy"&gt; &nbsp;
        &lt;channels&gt;ALL_CHANNEL&lt;/channels&gt;
        &lt;logMask&gt;INHERIT_MASK&lt;/logMask&gt;
      &lt;/Policy&gt;

      &lt;Format class="com.protomatter.syslog.SimpleSyslogTextFormatter"&gt; &nbsp;
        &lt;showCaller&gt;true&lt;/showCaller&gt;
        &lt;showChannel&gt;true&lt;/showChannel&gt;
        &lt;showHostName&gt;false&lt;/showHostName&gt;
      &lt;/Format&gt;

    &lt;/Logger&gt;

    &lt;!-- as many logger definitions as you want --&gt;

  &lt;/Syslog&gt;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
The <TT>&lt;Syslog&gt;</TT> element in the configuration file can
either be the root element of the document, or can also be
a direct child of the root element of the document.  This makes
it possible to integrate the configuration of syslog with
other XML-configured system in the same document.
</P>

<P>
Syslog will produce the default configuration and
write it out to the console if the
<tt><a href="xml/SyslogXML.html">com.protomatter.syslog.xml.SyslogXML</a></tt> class is
invoked from the command-line, like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  java com.protomatter.syslog.xml.SyslogXML &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
Syslog will also parse and validate any configuration
file passed in as the first command-line argument.
Default values are also filled in, and the resulting
configuration in printed to the console.  Invoke it
like this:
</P>

<P><UL>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0><TR><TD>
<PRE>

  java com.protomatter.syslog.xml.SyslogXML <I>config-file.xml</I> &nbsp;

</PRE>
</TD></TR></TABLE>
</UL></P>

<P>
The <TT>&lt;Syslog&gt;</TT> tag has the following attributes:
</P>

<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Attribute</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>defaultMask</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Must be "<TT>DEBUG</TT>", "<TT>INFO</TT>", "<TT>WARNING</TT>",
"<TT>ERROR</TT>" or "<TT>FATAL</TT>".
The log mask is set
to accept messages at or above the given level.  If this parameter
is omitted, the log mask is set to <TT>WARNING</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>hostname</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The hostname or IP address that Syslog believes to be the
local host.  This is set to whatever is returned by
<tt>InetAddress.getLocalHost()</tt> if not specified.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>flushThreadInterval</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
This will enable a background thread that will
flush all loggers periodically.  The setting is in
milliseconds -- 5000 is a good value to use.
Using this option in conjunction with setting
the <TT>&lt;autoFlush&gt;false&lt;/autoFlush&gt;</TT>
parameter on file-based loggers can significantly
increase performance.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>alwaysComputeCaller</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The flag which determines if Syslog always
computes calling class and method names at runtime.
Default is <tt>false</tt>.  If this is set to
<tt>true</tt> then the correct method name and caller
are always computed so they are available to the
log policies.  This can be overly expensive if you have
lots of log calls.  If this flag is set to <tt>false</tt>
then the caller class and method are only computed if
the log call passes the policy check, and if the
<tt>computeCaller</tt> flag is also set to <tt>true</tt>.
This should only be set to <tt>true</tt> if 
you have a special log policy which needs the method
name to perform its check.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>computeCaller</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The flag which determines if Syslog 
computes calling class and method names at runtime
before calling the log() method on a logger.
Default is <tt>false</tt>.  If this is set to
<tt>true</tt> then the correct method name and caller
are computed so they are available to the
logger (and therefore the message formatter).
This can be overly expensive if you have
lots of log calls.  It can be very useful during
debugging.
</TD>
</TR>

</TABLE>

<P>
Each logger is specified using a <TT>&lt;Logger&gt;</TT> tag inside
the <TT>&lt;Syslog&gt;</TT> tag.  It specifies a name for each
logger (which does not have to be unique, but probably should be) and
a <tt><a href="Syslogger.html">Syslogger</a></tt> implementation to use.  After the class is loaded,
it's default constructor is called.  After that, it is named and the
<TT>&lt;Logger&gt;</TT> tag is passed to the <tt>configure()</tt> method
so that the logger can configure itself.  The attributes for the
<TT>&lt;Logger&gt;</TT> tag are:
</P>

<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Attribute</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>name</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The symbolic name of the logger.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>class</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The full class name of the <tt><a href="Syslogger.html">com.protomatter.syslog.Syslogger</a></tt>
implementation to configure and use.  The class must have a
no-argument constructor.
</TD>
</TR>

</TABLE>

<P>
Here is a definitive list of the parameters that are understood by the
loggers included with Syslog:
</P>

<P>
<DL>
<DT><B><TT><a href="BasicLogger.html">BasicLogger</a></TT></B> (superclass for other loggers)</DT>
<DD>
This is the superclass for all the other loggers.  It provides basic
functionality like delegating to log policies, configuring the
text formatter, etc.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;Policy&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The log policy class and configuration to use.  If not specified,
the <TT><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT> class will be used.
The <tt>&lt;Policy&gt;</tt> element must have a <tt>class</tt>
attribute set which specifies the policy implementation.
The <tt>&lt;Policy&gt;</tt> element will be passed to
the <tt>configure()</tt> method on the policy.
The class specified must
implement the <TT><a href="LogPolicy.html">LogPolicy</a></TT> interface
and have a no-argument constructor.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;Format&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The log message formatting class and configuration to use.  If not specified,
the <TT><a href="SimpleSyslogTextFormatter.html">SimpleSyslogTextFormatter</a></TT> class will be used.
The <tt>&lt;Format&gt;</tt> element must have a <tt>class</tt>
attribute set which specifies the message formatter implementation.
The <tt>&lt;Format&gt;</tt> element will be passed to
the <tt>configure()</tt> method on the formatter.
The class specified must
implement the <TT><a href="SyslogTextFormatter.html">SyslogTextFormatter</a></TT> interface
and have a no-argument constructor.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="SimpleSyslogTextFormatter.html">SimpleSyslogTextFormatter</a></TT></B> (default log formatter)</DT>
<DD>
These parameters can be included in the <tt>&lt;Format&gt;</tt> element
in the configuration for a logger
since the <TT><a href="BasicLogger.html">BasicLogger</a></TT> passes that element into the
log formatter when it is configured.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;dateFormat&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The format to use for the log entry date.  This string must
conform to the date formatting specifications used by the
<TT>java.text.SimpleDateFormat</TT> class.  The default
value is "<TT>MM/dd/yyyy HH:mm:ss</TT>".
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;dateFormatTimeZone&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The name of the timezone to use for the date formatter.  The
default is whatever <TT>TimeZone.getDefault()</TT> returns
(the local timezone).
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;dateFormatCacheTime&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The number of milliseconds to cache a formatted date string.
This is a performance improvement since the <TT>SimpleDateFormat</TT>
class is not incredibly fast at formatting dates.  The default
is 1000 (1 second).
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showCaller&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the caller name
will be printed in the output.  Default is <TT>true</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showChannel&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the channel name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showThreadName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the thread name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showHostName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the host name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;hostWidth&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The size in characters of the host name portion of the format.
Default is <TT>15</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;classWidth&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The size in characters of the class name portion of the format.
Default is <TT>20</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;channelWidth&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The size in characters of the channel name portion of the format.
Default is <TT>15</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;threadWidth&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The size in characters of the thread name portion of the format.
Default is <TT>15</TT>.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="JDK14SyslogTextFormatter.html">JDK14SyslogTextFormatter</a></TT></B>
(extends <TT><a href="SimpleSyslogTextFormatter.html">SimpleSyslogTextFormatter</a></tt>)</DT>
<DD>
These parameters can be included in the <tt>&lt;Format&gt;</tt> element
in the configuration for a logger
since the <TT><a href="BasicLogger.html">BasicLogger</a></TT> passes that element into the
log formatter when it is configured.<P>

This class is the default when <B><TT><a href="BasicLogger.html">BasicLogger</a></TT></B>
initializes itself under JDK 1.4.  You will have to explicitly specify this format
class in XML configuration files.<P>

This class is able to accurately determine the class name, method name and
source file line number where the programmer called a logging method.  It uses
the new <TT>StackTraceElement</TT> feature from <TT>java.lang.Throwable</TT>.
This feature works transparently with the JDK 1.4 logging API also (<TT>java.util.logging.*</TT>).
It's pretty cool.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;overrideClass&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
    "<TT>true</TT>" or "<TT>false</TT>".  Should this format override
    whatever was passed in as the logger class argument?
    The default value is "<TT>true</TT>".
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;includeMethod&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
    "<TT>true</TT>" or "<TT>false</TT>".  Only used when <TT>overrideClass</TT>
    is set to "<TT>true</TT>".  Should this format include
    the method name where the log call was made in the class information?
    The default value is "<TT>true</TT>".
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;includeLineNumber&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
    "<TT>true</TT>" or "<TT>false</TT>".  Only used when <TT>includeMethod</TT>
    is set to "<TT>true</TT>".  Should this format include the
    line number where the log call was made in the class information?
    The default value is "<TT>true</TT>".
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="HTMLSyslogTextFormatter.html">HTMLSyslogTextFormatter</a></TT></B>
(extends <TT><a href="SimpleSyslogTextFormatter.html">SimpleSyslogTextFormatter</a></tt>)</DT>
<DD>
These parameters can be included in the <tt>&lt;Format&gt;</tt> element
in the configuration for a logger
since the <TT><a href="BasicLogger.html">BasicLogger</a></TT> passes that element into the
log formatter when it is configured.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;stylesheet&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The default value is "<TT>syslog-stylesheet.css</TT>".
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT></B> (default log policy)</DT>
<DD>
These parameters can be included in the <tt>&lt;Policy&gt;</tt> element
in the configuration for a logger
since the <TT><a href="BasicLogger.html">BasicLogger</a></TT> passes that element into the
policy when it is configured.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;channels&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
A comma and/or space separated list of channel names to listen to.
The symbolic names <TT>DEFAULT_CHANNEL</TT> and <TT>ALL_CHANNEL</TT>
are also allowed.  The default is <TT>ALL_CHANNEL</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;logMask&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Must be "<TT>DEBUG</TT>", "<TT>INFO</TT>", "<TT>WARNING</TT>",
"<TT>ERROR</TT>", "<TT>FATAL</TT>", "<TT>INHERIT_MASK</TT>"
or a list of distict levels with the "<TT>=</TT>" character in
front of each (such as "<TT>=INFO,=WARNING</TT>").
The log mask is set
to accept messages at or above the given level.  If this parameter
is omitted or set to <TT>INHERIT_MASK</TT>, the log mask is set to
inherit whatever the default log mask for Syslog as a whole is
(set using the <TT>Syslog.setLogMask(...)</TT> method).
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="PerChannelPolicy.html">PerChannelPolicy</a></TT></B>
(extends <TT><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT>)</DT>
<DD>
These parameters can be included in the <tt>&lt;Policy&gt;</tt> element
in the configuration for a logger
since the <TT><a href="BasicLogger.html">BasicLogger</a></TT> passes that element into the
policy when it is configured.<P>

This policy allows a very fine-grain of control on which messages from which
channels are logged.  The policy has a default log mask and channel list
which behaves like the <tt><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT>, but also contains a list
of policy groups.  Each policy group has it's own log mask and channel list
and a list of Perl5 regular expressions to match against the name of the
channel that issued a given log message.  If one of the patterns matches and the
log mask permits the message to be logged, it is logged.
If none of the policy groups match, then the policy's default log mask and
channel list are applied to decide if the message should be logged.<P>

This allows you to, for instance, log all messages on the <TT>OPERATIONS_CHANNEL</TT>
channel that are at or above the <TT>INFO</TT> level and come from any class
in or under the "<TT>com.protomatter.jdbc.pool</TT>" package or whose name
matches the "<TT>*InfoProducer*EJB</TT>" pattern, etc.  It can be as
simple or as complicated as you want.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;PolicyGroup&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
All configuration elements from the <tt><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></tt>
policy, and a collection of <TT>&lt;channelPattern&gt;</TT> and/or
<TT>&lt;channelName&gt;</TT> tags
specifying a set of Perl5 regular expression patters (and
explict class names) to match against the class names of log message issuers.
</TD>
</TR>

</TABLE>
</P>

Each <TT>&lt;PolicyGroup&gt;</TT> tag can contain
the following tags:
<P>

<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;channels&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
A comma and/or space separated list of channel names to listen to.
The symbolic names <TT>DEFAULT_CHANNEL</TT> and <TT>ALL_CHANNEL</TT>
are also allowed.  The default is <TT>ALL_CHANNEL</TT>.  You should
keep it at <TT>ALL_CHANNEL</TT> so that the later declarations
for <TT>&lt;channelName&gt;</TT> and <TT>&lt;channelPattern&gt;</TT>
elements later.  This is because the channel passes if the
channels listed here <I>and</I> one of the <TT>&lt;PolicyGroup&gt;</TT>
definitions matches.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;logMask&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Must be "<TT>DEBUG</TT>", "<TT>INFO</TT>", "<TT>WARNING</TT>",
"<TT>ERROR</TT>", "<TT>FATAL</TT>", "<TT>INHERIT_MASK</TT>"
or a list of distict levels with the "<TT>=</TT>" character in
front of each (such as "<TT>=INFO,=WARNING</TT>").
The log mask is set
to accept messages at or above the given level.  If this parameter
is omitted or set to <TT>INHERIT_MASK</TT>, the log mask is set to
inherit whatever the default log mask for Syslog as a whole is
(set using the <TT>Syslog.setLogMask(...)</TT> method).
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;channelName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
There can be as many of these tags as needed.
Each is an exact, full channel name used to match against the
name of the channel making a log request.  If you just want to
match a few channels, it's more efficient to explicitly
enumerate their names than to use a regular expression.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;channelPattern&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
There can be as many of these tags as needed.
Each is a Perl5 regular expression used to match against the
name of the channel making a log request.  The set of these patterns
for each policy group are converted to a single expression
of the form
"<TT><I>Expression-1</I>|<I>Expression-2</I>|...|<I>Expression-N</i></TT>"
(the logical or of the set)
for faster matching.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="PerClassPolicy.html">PerClassPolicy</a></TT></B>
(extends <TT><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT>)</DT>
<DD>
These parameters can be included in the <tt>&lt;Policy&gt;</tt> element
in the configuration for a logger
since the <TT><a href="BasicLogger.html">BasicLogger</a></TT> passes that element into the
policy when it is configured.<P>

This policy allows a very fine-grain of control on which messages from which
objects are logged.  The policy has a default log mask and channel list
which behaves like the <tt><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></TT>, but also contains a list
of policy groups.  Each policy group has it's own log mask and channel list
and a list of Perl5 regular expressions to match against the name of the
class that issued a given log message.  If one of the patterns matches and the
log mask and channel list permit the message to be logged, it is logged.
If none of the policy groups match, then the policy's default log mask and
channel list are applied to decide if the message should be logged.<P>

This allows you to, for instance, log all messages on the <TT>OPERATIONS_CHANNEL</TT>
channel that are at or above the <TT>INFO</TT> level and come from any class
in or under the "<TT>com.protomatter.jdbc.pool</TT>" package or whose name
matches the "<TT>*InfoProducer*EJB</TT>" pattern, etc.  It can be as
simple or as complicated as you want.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;PolicyGroup&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
All configuration elements from the <tt><a href="SimpleLogPolicy.html">SimpleLogPolicy</a></tt>
policy, and a collection of <TT>&lt;classPattern&gt;</TT> and/or
<TT>&lt;className&gt;</TT> tags
specifying a set of Perl5 regular expression patters (and
explict class names) to match against the class names of log message issuers.
</TD>
</TR>

</TABLE>
</P>

Each <TT>&lt;PolicyGroup&gt;</TT> tag can contain
the following tags:
<P>

<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>
<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;channels&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
A comma and/or space separated list of channel names to listen to.
The symbolic names <TT>DEFAULT_CHANNEL</TT> and <TT>ALL_CHANNEL</TT>
are also allowed.  The default is <TT>ALL_CHANNEL</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;logMask&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Must be "<TT>DEBUG</TT>", "<TT>INFO</TT>", "<TT>WARNING</TT>",
"<TT>ERROR</TT>", "<TT>FATAL</TT>", "<TT>INHERIT_MASK</TT>"
or a list of distict levels with the "<TT>=</TT>" character in
front of each (such as "<TT>=INFO,=WARNING</TT>").
The log mask is set
to accept messages at or above the given level.  If this parameter
is omitted or set to <TT>INHERIT_MASK</TT>, the log mask is set to
inherit whatever the default log mask for Syslog as a whole is
(set using the <TT>Syslog.setLogMask(...)</TT> method).
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;className&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
There can be as many of these tags as needed.
Each is an exact, full class name used to match against the
name of the class making a log request.  If you just want to
match a few classes, it's more efficient to explicitly
enumerate their names than to use a regular expression.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;classPattern&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
There can be as many of these tags as needed.
Each is a Perl5 regular expression used to match against the
name of the class making a log request.  The set of these patterns
for each policy group are converted to a single expression
of the form
"<TT><I>Expression-1</I>|<I>Expression-2</I>|...|<I>Expression-N</i></TT>"
(the logical or of the set)
for faster matching.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="TimeRolloverLog.html">TimeRolloverLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
This log writes to a file and rotates it on the minute,
hour, day or month change.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;baseName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The base filename of the log files that will be created.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;nameFormat&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
A date format that is appended to the <TT>baseName</TT>
when a new file is going to be written.  This string must
conform to the specification for date formats used by
the <TT>java.text.SimpleDateFormat</TT> class.  The default
value is "<TT>yyyy.MM.dd-HH.mm.ss</TT>".
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;extension&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The filename extension of the files that will be created.
The default is nothing.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;append&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- If a file that's about to be
written to already exists, should we append to it or overwrite it?
Default is <TT>true</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;autoFlush&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- Output to the
file is buffered to increate speed.  If this option is set to
<tt>false</tt> then buffering occurrs.  If it is
set to <tt>true</tt> (the default), then the output stream is flushed each
time a log entry is written.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;roll&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
Must be "<TT>ROLL_MINUTELY</TT>", "<TT>ROLL_HOURLY</TT>", "<TT>ROLL_DAILY</TT>",
"<TT>ROLL_WEEKLY</TT>" or "<TT>ROLL_MONTHLY</TT>".  Determines how frequently the
log file will be rotated.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;weeklyRollDay&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Default is "<TT>MONDAY</TT>".  If the value for the <TT>roll</TT> parameter
is <tt>ROLL_WEEKLY</TT> this determines what day to roll the log.  The
log will roll the file when the day changes to the given day.  For
instance, if this is set to <TT>MONDAY</TT>, then sunday night at
midnight the file will be rotated.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>




<P>
<DL>
<DT><B><TT><a href="LengthRolloverLog.html">LengthRolloverLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
This log writes to a file and rotates it before it gets to be
a certain size.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;baseName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The base filename of the log files that will be created.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;extension&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The filename extension of the files that will be created.
The default is nothing.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;append&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- If a file that's about to be
written to already exists, should we append to it or overwrite it?
Default is <TT>true</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;autoFlush&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- Output to the
file is buffered to increate speed.  If this option is set to
<tt>false</tt> then buffering occurrs.  If it is
set to <tt>true</tt> (the default), then the output stream is flushed each
time a log entry is written.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;rollSize&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The maximum size (in bytes) of the log file.  Default is 1MB.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>




<P>
<DL>
<DT><B><TT><a href="FileLog.html">FileLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Simply writes messages to a file.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;fileName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The filename of the log file that will be created.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;append&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- If a file that's about to be
written to already exists, should we append to it or overwrite it?
Default is <TT>true</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;autoFlush&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- Output to the
file is buffered to increate speed.  If this option is set to
<tt>false</tt> then buffering occurrs.  If it is
set to <tt>true</tt> (the default), then the output stream is flushed each
time a log entry is written.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>



<P>
<DL>
<DT><B><TT><a href="OpenFileLog.html">OpenFileLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;fileName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The filename of the log file that will be created.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;append&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- If a file that's about to be
written to already exists, should we append to it or overwrite it?
Default is <TT>true</TT>.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>



<P>
<DL>
<DT><B><TT><a href="PrintWriterLog.html">PrintWriterLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Writes messages to a printwriter (such as <tt>System.out</TT> or
<TT>System.err</tt>).
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;stream&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The name of the stream to attach to.  Must be either
"<TT>System.out</TT>" or "<TT>System.err</TT>".
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>



<P>
<DL>
<DT><B><TT><a href="DatabaseLog.html">DatabaseLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Writes messages to a database via JDBC.  This logger
maintains a connection to a database where log entries
will be written.  It truncates data to pre-defined
lengths before attempting to write to the database.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;driver&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The JDBC driver class to use when connecting to the database.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;url&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The JDBC URL to use when connecting to the database.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;numRetries&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The number of times to attempt writing each message to the database.
After the first error, the JDBC connection is re-initialized.  If
the message cannot be written after the given number of tries,
the message and an explanation of what went wrong writing to
the database is printed to <TT>System.err</TT>.  The default
is 3.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;tablePrefix&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The name prefix for tables.  See the JavaDoc for this
logger for information about the necessary table structure.
Default is nothing.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;messageWidth&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
    The width of the column that is used to write
    the short message.  Default is <TT>255</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;detailWidth&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
    The width of the column that is used to write
    the message detail.  Default is <TT>4000</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;statementAdapter&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
    The name of a class which implements the
    <TT><a href="DatabaseLogStatementAdapter.html">DatabaseLogStatementAdapter</a></TT>
    interface.  Since different database drivers work
    differently with data types, this abstracts the code that sets
    the <TT>PreparedStatement</TT> variable for the message
    detail column.  There are several implementations of this
    which are included with Syslog:
    <TT><a href="StringDatabaseLogStatementAdapter.html">setString()</a></TT>,
    <TT><a href="AsciiStreamDatabaseLogStatementAdapter.html">setAsciiStream()</a></TT>, and
    <TT><a href="CharacterStreamDatabaseLogStatementAdapter.html">setCharacterStream()</a></TT>.
    If you have to write a custom one for some driver, please
    let me know so it can get included with the standard distribution.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;ConnectionProperties&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Contains a set of <TT>&lt;property&gt;</TT> elements,
each containing a <TT>&lt;name&gt;</TT> and
<TT>&lt;value&gt;</TT> element defining the connection
properties.
</TD>
</TR>

</TABLE>

</DD>
</DL>
</P>

<P>
<DL>
<DT><B><TT><a href="JMSLog.html">JMSLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Publishes log messages onto a JMS topic.  This effectively provides
a way to manage Syslog messages inside JTA transactions when operating
inside a J2EE application server, such as BEA WebLogic.  Messages
can be pulled off the JMS topic remotely for further processing on
a log server.  See the javadoc for this logger, and for the
<tt>com.protomatter.syslog.SyslogServer</tt> class for more information.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;topicName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The JNDI location of a JMS topic to publish messages to.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;factoryName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
The JNDI location of a JMS connection factory to use
to attach to the JMS system.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;connectionUser&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The username to use while creating a JMS connection.  This is
not related to JNDI credentials.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;connectionPass&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The password to use while creating a JMS connection.  This is
not related to JNDI credentials.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;persistent&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Should the JMS messages be persistent.  Default is
<tt>false</tt>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;ttl&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The JMS message time to live, in milliseconds.  Default
is 30 minutes.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;priority&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The JMS message priority.  Default is <tt>5</tt>.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="UNIXSyslogLog.html">UNIXSyslogLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Sends UDP packets to a UNIX syslog server.  This effectively
bridges Syslog messages into the UNIX syslog facility.  You can,
for instance, end up doing a <tt>wall</tt> on a UNIX machine
when to make a call to <tt>Syslog.fatal()</TT> and you can get
calls to <tt>Syslog.info()</TT> written into <tt>/var/log/messages</TT>.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;logServer&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD>
Hostname or IP address of the UNIX syslog server.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;port&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The port number to send packets to on the UNIX machine.
Default is <TT>514</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;facility&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The UNIX syslog facility ID to use.  See RFC 3164 for
complete information.  The <a href="xml/UNIXSyslogLog_Helper.html#configure(java.lang.Object, org.jdom.Element)">JavaDoc</A>
for the XML configuration class explains it in more detail.  A list of the
available facilities can be found <a href="UNIXSyslogLog.html#setFacility(int)">here</a>.
Default is <TT>16</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;tag&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The "tag" value for the UDP packets.  This is meant to be
the "application" or "process" name in UNIX.
Default is "<TT>ProtomatterSyslog</TT>".
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showHostname&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
Should the hostname be included in the packet before
the "tag" ?  The spec (RFC 3164) says that you should,
but when I tested under Red Hat Linux 7.2, it just
ended up repeating the hostname in the log.  Your
mileage may vary.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>messageTemplate</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The template for formatting the body of the message.  The
following tokens are replaced in this string:<P>
 <ul>
 <table border=0 cellpadding=3 cellspacing=0>
   <tr><td><tt>{0}</tt></td><td>Channel name</td></tr>
   <tr><td><tt>{1}</tt></td><td>Full caller class name (with package)</td></tr>
   <tr><td><tt>{2}</tt></td><td>Caller class name</td></tr>
   <tr><td><tt>{3}</tt></td><td>Short message</td></tr>
   <tr><td><tt>{4}</tt></td><td>Thread name</td></tr>
   <tr><td><tt>{5}</tt></td><td>Severity ("<tt>DEBUG</tt>" ... "<tt>FATAL</tt>")</td></tr>
 </table>
 </ul><P>

 Default is <nobr>"<tt>[{5}] {2}: {3}</tt>"</nobr>.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><tt>SeverityMap</tt></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>
Contains a set of <TT>&lt;MapEntry&gt;</TT> elements,
each containing a <TT>&lt;syslog&gt;</TT> and
<TT>&lt;unix&gt;</TT> elements.  Valid values for
the <TT>&lt;syslog&gt;</tt> element are <TT>DEBUG</TT>,
<TT>INFO</TT>, <TT>WARNING</TT>, <TT>ERROR</TT> and
<TT>FATAL</TT>.  You <i>must</i> specify map entries for
<i>all</i> of the syslog severities.  Each must map to
a UNIX syslog severity, whose legal values are:
<TT>DEBUG</TT>, <TT>INFO</TT>, <TT>NOTICE</TT>,
<TT>WARNING</TT>, <TT>ERROR</TT>, <TT>CRITICAL</TT>
and <TT>EMERGENCY</TT>.<P>

Default is:<P>

<ul><tt>
    &lt;SeverityMap&gt;<BR>
    &nbsp;&nbsp;&lt;MapEntry&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;syslog&gt;DEBUG&lt;/syslog&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;unix&gt;DEBUG&lt;/unix&gt;<BR>
    &nbsp;&nbsp;&lt;/MapEntry&gt;<BR>
    &nbsp;&nbsp;&lt;MapEntry&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;syslog&gt;INFO&lt;/syslog&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;unix&gt;INFO&lt;/unix&gt;<BR>
    &nbsp;&nbsp;&lt;/MapEntry&gt;<BR>
    &nbsp;&nbsp;&lt;MapEntry&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;syslog&gt;WARNING&lt;/syslog&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;unix&gt;WARNING&lt;/unix&gt;<BR>
    &nbsp;&nbsp;&lt;/MapEntry&gt;<BR>
    &nbsp;&nbsp;&lt;MapEntry&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;syslog&gt;ERROR&lt;/syslog&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;unix&gt;ERROR&lt;/unix&gt;<BR>
    &nbsp;&nbsp;&lt;/MapEntry&gt;<BR>
    &nbsp;&nbsp;&lt;MapEntry&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;syslog&gt;FATAL&lt;/syslog&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;unix&gt;EMERGENCY&lt;/unix&gt;<BR>
    &nbsp;&nbsp;&lt;/MapEntry&gt;<BR>
    &lt;/SeverityMap&gt;<BR>
</tt>
</ul>


</TD>
</TR>



</TABLE>
</DD>
</DL>
</P>



<P>
<DL>
<DT><B><TT><a href="RemoteLog.html">RemoteLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Writes messages to (possibly) remote objects bound into
the local JNDI tree.  Messages can be received remotely
for further processing on a log server.  See the javadoc
for this logger, and for the
<tt><a href="SyslogServer.html">com.protomatter.syslog.SyslogServer</a></tt>
class for more information.  It has no configuration parameters
of its own.
</DD>
</DL>
</P>



<P>
<DL>
<DT><B><TT><a href="MailLog.html">MailLog</a></TT></B>
(extends <TT><a href="BasicLogger.html">BasicLogger</a></TT>)</DT>
<DD>
Sends email by connecting directly to an SMTP server.  The message
can either be plain text or can be HTML formatted.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;SubjectFormat&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The mail message subject formatting class and configuration
to use.  If not specified, the
<TT><a href="SimpleSyslogMailSubjectFormatter.html">SimpleSyslogMailSubjectFormatter</a></TT>
class will be used.  The <tt>&lt;SubjectFormat&gt;</tt> element
must have a <tt>class</tt> attribute set which specifies the
message subject formatter implementation.  The
<tt>&lt;SubjectFormat&gt;</tt> element will be passed to
the <tt>configure()</tt> method on the formatter.
The class specified must implement the
<TT><a href="SyslogMailSubjectFormatter.html">SyslogMailSubjectFormatter</a></TT> interface
and have a no-argument constructor.
</TD>
</TR>

</TABLE><P>

<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>
<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;server&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD VALIGN=TOP>The SMTP server hostname or IP address.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;port&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>The port number on the SMTP server to connect to.
  The default value is 25.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;workQueue&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD VALIGN=TOP>The symbolic name of a work queue to use.  If
left blank, the default work queue will be used.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;html&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>Should the message be sent as a MIME message?
    <tt>true</tt> or <tt>false</tt>.  If this is
    set to <tt>true</tt>, it is expected that the
    message formatter will actually produce HTML.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;to&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD VALIGN=TOP>A comma-separated list of email addresses to send
    messages to.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;cc&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>A comma-separated list of email addresses to
    include in the CC (carbon-copy) list.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;bcc&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>A comma-separated list of email addresses to
    include in the BCC (blind carbon-copy) list.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;from&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>yes</TD>
<TD VALIGN=TOP>The email address that the mail should appear
    to be from.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;fromName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>The name (not address) that the mail should
    appear to be from.
</TD>
</TR>

<TR CLASS="TableRowColor">
<TD VALIGN=TOP><TT>&lt;transportAgentName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD VALIGN=TOP>The name of the transport agent as it
identifies itself to the remote SMTP server.  The default
is "<TT>protomatter-syslog-agent</TT>".
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>


<P>
<DL>
<DT><B><TT><a href="SimpleSyslogMailSubjectFormatter.html">SimpleSyslogMailSubjectFormatter</a></TT></B>
(default mail subject formatter)</DT>
<DD>
These parameters can be included in the <tt>&lt;SubjectFormat&gt;</tt> element
in the configuration for a <TT><a href="MailLog.html">MailLog</a></tt> logger
since the <TT><a href="MailLog.html">MailLog</a></TT> passes that element into the
subject formatter when it is configured.
<P>
<TABLE BORDER=1 CELLPADDING=4 CELLSPACING=0>

<TR>
<TH ALIGN=LEFT>Element</TH>
<TH ALIGN=LEFT>Required?</TH>
<TH ALIGN=LEFT>Description</TH>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;dateFormat&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The format to use for the log entry date.  This string must
conform to the date formatting specifications used by the
<TT>java.text.SimpleDateFormat</TT> class.  The default
value is "<TT>HH:mm:ss MM/dd</TT>".
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;dateFormatTimeZone&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The name of the timezone to use for the date formatter.  The
default is whatever <TT>TimeZone.getDefault()</TT> returns
(the local timezone).
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;dateFormatCacheTime&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
The number of milliseconds to cache a formatted date string.
This is a performance improvement since the <TT>SimpleDateFormat</TT>
class is not incredibly fast at formatting dates.  The default
is 1000 (1 second).
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showCaller&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the caller name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showChannel&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the channel name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showThreadName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the thread name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

<TR>
<TD VALIGN=TOP><TT>&lt;showHostName&gt;</TT></TD>
<TD ALIGN=CENTER VALIGN=TOP>no</TD>
<TD>
"<TT>true</TT>" or "<TT>false</TT>" -- determines if the host name
will be printed in the output.  Default is <TT>false</TT>.
</TD>
</TR>

</TABLE>
</DD>
</DL>
</P>








</DD>

<DT><H3></H3></DT>
<DD>
</DD>

</DL>

<P>&nbsp;</P>
<H2>Miscellaneous</H2>
<DL>

<DT><H3>Online Resources</H3></DT>
<DD>
<P>
<a href="http://protomatter.sourceforge.net">http://protomatter.sourceforge.net</a>
-- the protomatter software site hosted by
<a href="http://sourceforge.net">SourceForge.net</a>.
The latest version of these classes (and this whitepaper) are always
available there.
</P>
</DD>

<DT><H3>Future Direction</H3></DT>
<DD>
<P>
There are really two things that I'd like to add to Syslog at this point:

<DL>

<DT><I>JMX Management</I></DT>
<DD>
This is really my Holy Grail at this point.  The idea is to add a series
of JMX beans to allow Syslog to be configured from a JMX console.  This
could prove to be much better than using a text editor to play with
configurations.
</DD>

<DT><I>XML Schema Support</I></DT>
<DD>
I think it would be nice to have the XML configurations checked by an
XML schema.  Right now, there's no DTD, and there's no schema, so all
the data is checked programatically.  This works really well, though,
especially since it's possible to add entirely new configuration
information by subclassing existing objects.  Getting this kind of
thing to work with a DTD or an XML schema could be tricky.  In any case,
it's something to look into.
</DD>

</DL>

</P>

</DD>

</DL>


</BODY>
</HTML>
